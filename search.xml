<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MVC Backbone]]></title>
      <url>%2F2017%2F03%2F11%2FMVC-Backbone%2F</url>
      <content type="text"><![CDATA[最近阅读了《基于MVC的JavaScript web富应用开发》（后文简称《MVC》），文章第十二章介绍了 Backbone.js，再次激发了我对此框架的兴趣。在看这本书之前了解过 vue，也被其所吸引，而正如作者分享的经验， MVC 是 MV* 发展的前身。也因此让自己想要更加深入地去了解，MVC 到底是什么？正好也从 Backbone 入手来学习这类库（框架）的设计思想。 Backbone 的特点 Backbone 是构建 JavaScript 应用程序的一个优秀类库。他的优美之处在于其简洁。这是一个轻量类库，覆盖了基础的功能，同时提供了最大的灵活性。（大小请参阅官方文件）MVC 是贯穿 Backbone 核心的模式。提供了模型、控制器和视图——骨架。Backbone 唯一以来 underscore.js，其提供非常有用的工具和 js 函数。除了 underscore，还可以使用 jQuery zepto 来提升 Backbone 处理视图的能力 引用来自《MVC》-chapter 12 知乎上关于 Backbone 的回答 作者：pw来源：知乎 链接著作权归作者所有，转载请联系作者获得授权。 Backbone 最适合的应用场景是单页面应用，并且页面上有大量数据模型，模型之间需要进行复杂的信息沟通。Backbone 在这种场景下，能很好的实现模块间松耦合和事件驱动。 其他适用产品还有微博，网易微博的前端设计也是和 Backbone 类似的一个结构。 Backbone 的优点和一些经验 Tip： View 的划分将页面上的视图元素解耦，粒度细化。View 间通过事件和 Model 通讯，避免了 DOM 事件的滥用。Model 和 Restful 的通讯方式对于后端人员非常友好。 MVC 架构清晰， 我有个常年写 Java 没写过 JS 的同事看 Backbone 很快就了解了整体设计，虽然这时候他还是不会写 JS。 Collection/Model 抽象了以前杂乱的 AJAX 请求，CRUD 请求变得非常非常方便。 强烈建议 View -&gt; Model 单向依赖，世界会美好很多。 配上一个模块化加载器例如 SeaJS 会很爽。 Backbone 的一些缺点，或者说一些尚未实现的 Feature： Model 层比较简单，如果要支持 One-To-One 或者 One-To-Many 等复杂数据关系时有些力不从心。还有 一个 Model 只能属于一个 Collection 这个设计，页面复杂的时候会很受局限。例如这个问题： http://www.zhihu.com/question/19843899 （补充：Backbone.Relations 插件是这个问题的一个解决方案 https://github.com/PaulUithol/Backbone-relational By zjhiphop） 同上，Model 只有基本的 CRUD 操作，不能很好的扩展，Backbone.sync 方法写的不太灵活，要想扩展就得重写 sync 方法。 View 层没有很强的 Page 管理机制，比如通过 URL 切换改变整个页面时，页面上尚存的 View 如何处理？直接销毁的话，是否要销毁关联的 Model、Collection？Cache 住？如何管理 Cache？ 内存管理需要比较小心，缺乏机制避免创建重复 Model。 extends override 父类方法的时候得写一串的 SuperClass.prototype.someMethod.apply 什么的，就不能实现个 _super 方法么…… 对调试非常不友好。 作者有代码洁癖（也是加分项），this.$el 大家呼唤了这么久才加上，估计今生也看不到 this._super。更新慢。 总体来说 Backbone 还很轻，框架很漂亮但是有些细节还比较粗糙。用之前要做好对 Backbone 进行大量扩展甚至 Hack 的准备。 模型1Backbone.Model 模型是保存应用程序数据的地方。可以想象为 APP 原始数据精心设计的抽象，并且添加了一些工具函数和事件。 模型和属性使用 set() 和 get() 来设置和获取实例中的属性。12var user = new User();user.set(&#123;name: "yevvb"&#125;);//hash 形式的表示对象 集合集合就是对模型实例的数据进行管理。文章中举了重建 twitter 关注和粉丝的例子，FOLLOWERS 和 FOLLOWEES，两者都是由 User 实例来填充数据，虽然来自于同一个 Model，但是包含了不同的 Model 实例（User 实例）。 控制集合内部顺序123456var Users = Backbone.Collection.extend(&#123; // 通过 comparator（） 函数来实现 comparator: function(user)&#123; return user.get("name"); &#125;&#125;); 视图Backbone 视图并不是模板本身，而是一些控制类。代表了一个 UI 逻辑块，负责一个简单的 DOM 的内容。比如说：控制元素的显隐，按钮的不同状态等等… 12345var UserView = Backbone.View.extend(&#123; el: $(&quot;.users&quot;)&#125;);new UserView(&#123;id: &quot;followers&quot;&#125;); 渲染视图每个视图都有一个 render() 函数，默认情况不做任何操作。一旦视图修改就需要 repaints，就应该调用此函数。模板可以依赖于其他工具 underscore 等等都可以。 即使是未插入到页面中去的 model 实例，其仍旧拥有自己的 el 元素，视图可在任何时候渲染，然后一次性插入到 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。 12345678var TodoView = Backbone.View.extend(&#123; template: _.template($(&quot;#todo-template&quot;).html()), render: function() &#123; $(this.el).html(this.template(this.model.toJSON())); // 返回以便于链式调用，非常重要 return this; &#125;&#125;); 委托时间事件必不可少，他是用户行为–交互的基础。 Backbone 视图提供了一种添加事件到 el 的快捷方法。12345678var TodoView = Backbone.View.extend(&#123; events: &#123; &quot;change input[type=checkbox]&quot; : &quot;toggleDone&quot;, &quot;click .destroy&quot; : &quot;clear&quot;, &#125;, toggleDone: function(e)&#123; /* ... */&#125;, clear: function(e)&#123; /* ... */&#125;&#125;); 绑定和上下文一旦视图发生改变，就会触发 change 事件，使得应用程序的视图和与之对应的模型数据是同步绑定的。而此时唯一需要注意的是 this 指示的上下文会发生变化。 控制器Backbone 的控制器将应用程序的状态和 URL 的 hash 片段关联在一起，使 URL 地址可分享，也可作为书签使用。本质上，控制器由一些路由和函数构成，当导航到这些路由时那些函数就会被调用。 123456789101112131415var PageController = Backbone.Controller.extend(&#123; routes: &#123; &quot;&quot;: &quot;index&quot;, &quot;help&quot;: &quot;help&quot;, // #help &quot;search/:query&quot;: &quot;search&quot;, // #search/kiwis &quot;search/:query/p:page&quot;: &quot;search&quot; // #search/kiwis/p7 &#125;, index: function()&#123; /* ... */ &#125;, help: function() &#123; // ... &#125;, search: function(query, page) &#123; // ... &#125;&#125;); 与服务器同步的问题第一次如何从服务器获取模型数据（fetch）服务器端如何存储如何自定义行为todo 应用实践 总结：backbone 为我们解耦了模型、视图和控制层，结构清晰简洁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
