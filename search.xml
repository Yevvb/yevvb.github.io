<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[You don't know JavaScript(Chapter 1.2-1.3)]]></title>
      <url>%2F2017%2F03%2F16%2FYou-Don't-Know-Javascript2%2F</url>
      <content type="text"><![CDATA[什么是词法化和词法作用域？ 你知道为什么不推荐 eval(…) 和 with 吗，以及这两者如何造成了性能下降的？ 什么是函数作用域？ 私有变量是怎么实现的？ 命名空间如何规避冲突？匿名函数的写法以及有点在哪儿？ ES6又是如何实现块作用域，babel 又是如何将其编译成兼容ES5的呢？ try/catch 仅仅用来调试吗？ 词法作用域回到编译器工作的第一个阶段，叫做词法化（单词化）。即对源代码中的字符进行检查，如果是有状态的解析过程，还会富裕单词意义。 词法作用域就是定义在词法阶段（查找标识符）的作用域。换句话说，就是在你写代码的时候你的变量和块作用域写在哪里，就决定了词法作用域的范围，这一切都是可以估量的（那么什么是不可预计的呢？），因此在词法分析阶段会保持作用域不变。（书写位置决定范围） 查找，作用域查找会在找到都一个匹配的标识符停止。在多层嵌套作用域中可以定义同名的标识符，这叫做遮蔽效应（内部遮蔽外部唯一吗？），查找由内而外。 备注：全局变量会自动成为全局对象（window、global）的属性，因此可以通过全局对象属性的引用来进行访问（对于被遮蔽的变量能够通过这种方式查到，但是仅限于全局变量，非全局则是被替换）。 欺骗词法 eval &amp; with eval: 我们经常动态插入代码，而引擎则会认为被 eval 插入的代码所处位置就是 eval 所处的作用域，这就导致了该词法作用域会在运行期间被修改（例如声明局部变量导致内容被替换等等）。 with：通常被当做重复引用一个对象中多个属性的快捷方式，问题就出在这里，万一里面包含了词法作用域内没有的属性或变量，那么就会造成全局污染（非严格模式下赋值查询的弊端）。需要注意的是，with 可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，同时将该对象的属性定义为词法作用域的词法标识符。 这两种方式都会造成词法解析过程的不确定性，因为无法对作用域查找进行优化，引擎会认为我做的这些都是白做的，最终的结果就是性能的严重下降，甚至是带来安全的隐患。 好消息是：严格模式下两则都被禁用了。 函数作用域和块作用域请把一个函数作用域想象成一个气泡（虽然不合理） 函数中的作用域 属于这个函数的全部变量都可以在整个函数的范围内使用以及复用（实际在嵌套的作用域中也可以访问）。这样的设计方案，充分利用了 JavaScript 变量可根据需要改变值类型的‘动态’特性。与此同时，意味着全局变量随时都能被任意位置访问，这就会带来意想不到的结果。 隐藏内部实现 123456789101112function doSomething(a) &#123; b = a + doSomethingElse( a * 2 ); console.log( b * 3）；&#125;function doSomethingElse(a) &#123; return a - 1;&#125;var b;doSomething( 2 ); // 15 这是一段原文中的例子，b 和 doSomethingElse 本该是 doSomething 的内部实现，然后因为写在函数外部，使得外部作用域拥有‘访问权限’，一旦被修改，那么我们就无法从 doSomething 得到我们预期想要的结果。这就是为何需要隐藏！ 先声明函数，然后在里面写代码是传统的思维。反过来思考，将一段代码挑选出来，用函数声明对其进行包装，实际上就相当于将代码隐藏了。于是就在这个代码片段周围新建了一个作用域气泡。（用作用域去隐藏一段代码，为什么要隐藏？） 软件设计的最小授权或最小暴露原则，指的是最小限度地暴露必要内容，而将其他内容都‘隐藏’起来，比如某个模块或对象的 API 设计。阻止部分访问，实现变量或函数的私有。 规避冲突 12345678910111213function foo() &#123; function bar(a) &#123; i = 3; //修改了 for 循环所属作用域中的 i console.log( a + i ); // a 为8，所以输出 11，但是 i 还是为3 &lt; 10 &#125; for (var i=0; i&lt;10; i++) &#123; console.log(i); // 3 + 1 = 4 bar( i * 2); //糟糕，无限循环了！因为声明会提前，赋值是运行到哪儿才会执行哪儿 &#125;&#125;foo() // 日志打印(4 11)无限循环; 看上面的例子，因为 bar 函数内部忘记声明变量 i（隐藏），导致全局创建了 i 变量，以致于污染了 for 循环（循环内var 会提到 foo的顶部，在执行 bar 时 i 被赋值，所以 i 始终为 3）。 前面我们提过‘遮蔽效应’，‘隐藏’作用域中的变量和函数带来的好处就是可以避免同名标识符之间的冲突。 全局命名空间：第三方库在实现过程中如果没有妥善地将内部私有函数和变量隐藏起来，那么就极易引发冲突（jQuery 的实现，$/jquery 的使用）。 模块管理：现代的模块机制，使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式导入到另外一个特定的作用域中（webpack 就是一个模块化打包工具，require/AMD/ES6 moudle 是规范）。 函数作用域 上面我们提到如何隐藏内部实现，通过包装函数来讲变量或者函数隐藏起来，但是这仍旧会生成一些具名函数（比如 foo()），这就意味着 foo 这个名字本身‘污染’了当前作用域。12345678(function foo() &#123; // &lt;-- 注意开头 （function... var a = 3; console.log(a); // 3&#125;)(); // &lt;-- 注意结尾 ...)()console.log( a ); //Uncaught ReferenceError: a is not defined 可以看到外部无法访问到 a 变量。 该包装函数声明以（function… 而不是以 function… 开始，函数会被当做函数表达式而不是一个标准的函数声明来处理。 !important &gt;&gt;&gt; 区分函数声明和表达式最简单的方法是看 function 关键字出现的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。(function foo() { .. }) 作为函数表达式意味着，foo 只能在 .. 所代表的位置中被访问，外部作用域作为无法访问，也就不会非必要的污染外部作用域。 匿名和具名 来看一个熟悉的场景：123setTimeout( function() &#123; console.log('blablabla')&#125;, 1000); 这个叫做匿名函数表达式，因为 function() {} 没有函数名，也就是名称标识符。函数表达式可以匿名，但是函数声明则不可以省略函数名————非法操作。 匿名函数表达式的缺点： 匿名函数在栈追踪不会显示出有意义的函数名，使得调试很困难。 没有函数名，当需要进行引用的时候只能用 过期的 arguments.callee 引用，例如递归，例如事件触发之后解除监听。 匿名函数省略了函数名，代码可读性变差。 解决办法：行内函数表达式————匿名和具名都对此无影响，解决了上述问题；1234// 最佳实践setTimeout( function timeoutHandler() &#123; console.log('blablabla')&#125;, 1000); 立即执行函数表达式 函数写在括号内变成了一个函数表达式，那么在后面加一对括号，就可以立即执行这个函数。 IIFE：（Immediately Invoked Function Expression）立即执行函数表达式 12345var a = 3;(function IIFE(a) &#123; console.log(a); &#125;)(2);console.log(a); // 3 另外一种写法，功能上一致，任凭喜好：12345var a = 3;(function IIFE(a) &#123; console.log(a); &#125;(2));console.log(a); // 3 IIFE 用法进阶： 1234567891011var a = 2;(function (global) &#123; var a = 3; console.log(a); //3 console.log(global.a); // 2 &#125;)(window);console.log(a); // 2 可以帮助你改进代码风格，使得对全局对象的引用变得比引用一个没有‘全局’资源的变量更加清晰（global.a 很明显是全局变量）。 还有一种常见的模式，就是参数默认为 undefined 1234567891011undefined = true; // 这里有坑(function IIFE( undefined ) &#123; var a; if (a === undefined) &#123; console.log("Undefined is safe here") &#125; &#125;)(); 目的是为了解决 undefined 标识符的默认值被错误覆盖导致的异常，这样的话即使在对于位置不传入任何值，内部的 undefined 还是 undefined。 IIFE 倒置代码运行顺序的用法（广泛用于 UMD 项目，其实看完会发现函数表达式内部会有一次调用参数（这里是传入进去的函数）的过程，参数（函数）会在这里执行）： 1234567891011121314151617181920212223var a = 2;console.log('one step');(function IIFE( def ) &#123; console.log('two step'); def( window ); console.log('three step');&#125;)(function def( global ) &#123; console.log('four step'); var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 console.log('five step');&#125;);// one step// two step// four step// 3// 2// five step// three step 这里让我想到了一个问题，操作符的优先级。MDN 上有介绍。 函数表达式 def 定义在片段的第二部分，然后当做参数（这个参数也叫做 def ）被传进 IIFE 函数定义的第一部分中。最后，参数 def （也就是传进去的函数）被调用，并将 window 传入当做 global 参数的值。 块作用域 函数作用域是 JS 中最普遍的作用域单元，但是其他类型也是存在的，而且实现维护起来可以更加优秀和简洁。 主要使用 JavaScript 开发的会对块作用域很陌生（非常赞同，以前甚至没有听过） 看个例子吧： 1234for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125;//你居然和我说这个就是块作用域？ 通常我们在 for 循环头部定义变量 i，事实上，我们只想在 for 循环内部的上下文使用它（没错=。=），而忽略了 i 会被绑定在外部作用域（函数或者全局）的事实（意思就是 for 循环不会像函数那样生成作用域气泡）。 再看一个例子： 1234567var foo = true;if (foo)&#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125; 同样是 if 条件，同样不会生成作用域气泡，那么你在里面使用 var，bar 最终还是属于外部作用域。这段代码只是为了可读性而可以伪装出的形式上的块作用域，如果用了，要确保没在其他地方使用 bar 只能靠自觉，这是不可取的。 with with 其实就是一个块左右的例子，因为他会单独生成一个作用域气泡，而且用 with 对象创建出的作用域仅在 with 声明中而非外部作用域中有效。 try/catch 很少人知道 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分局会创建一个块作用域。（我认为本书作者牛的地方就在这里，真的带你去了解任督二脉） 12345678910try &#123; undefined(); //执行一个非法操作来强制制造一个错误 err 用 undefined();&#125;catch( err ) &#123; console.log( err ); // TypeError: undefined is not a function&#125;console.log( err ); // ReferenceError: err is not defined 我们可以看到 err 仅在 catch 内部可以被访问，而在外部无法获得 undefined(); 来强制生成错误catch( err ){…}; 来捕获错误信息这个行为已经被标准化，除了IE其他浏览器大部分都已实现。但是当用一个作用域中的两个或者多个 catch 分句用同样的标识符名称声明错误变时，很多静态检查工具会发出警告。实际上我们知道因为 catch 实际上是块作用域，所以并不是重复定义变量，因为所以得变量都被安全的限制在 catch 块作用域内部。所以有人会命名 err1，err2 等等，有人则直接关闭静态检查工具对重复变量名的检查。这个其实很有用，因为能够帮助人们将 ES6 的一些新特性编译成能够兼容 ES5 的代码。 let 作业就是将变量绑定在 {…} 内部，同意 if 和 for 这些不会生成作用域气泡的条件语句也能够拥有自己私有的变量了。（想想还真是记得(≧▽≦)/！） 同样道理，直接将 let 写在 {…} 内部会隐式的将变量附加在一个块作用域上，如果没有密切关注，仍旧习惯性的移动就会导致代码混乱。解决办法就是认为添加一个显式的块： 123456789if foo &#123; &#123; // &lt;-- 显式的块 let bar = foo * 2; bar = something( bar ); console.log( bar ); &#125;&#125;console.log( bar ); // ReferenceError 垃圾回收 块作用域非常有用，这牵扯到闭包的垃圾回收机制相关。 这里留一个疑问？为什么闭包会导致垃圾无法及时回收呢？使用块作用域，能清楚的告知 JS 引擎，那些变量是使用一次后不再被使用的。 let 循环 12345for (let i=0; i&lt;10; i++) &#123; console.log( i ); // 1 2 3 4 5 6 7 8 9&#125;console.log( i ); // ReferenceError let 在 for 循环中的使用，实际上是将 i 绑定到了 for 循环的块中，而且是绑定到具体每一次循环迭代，确保使用上一个循环迭代结束时的值重新进行赋值。 12345678&#123; let j; for (let j=0; j&lt;10; j++) &#123; let i = j; console.log( i ); // 0 1 2 3 4 5 6 7 8 9 &#125;&#125;;console.log( j ); // RefeerenceError const const 同样用来可以创建作用域变量，但是其值为固定的（常量–&gt;如果是对象，那么固定的是其引用地址）。之后任何修改都会引起错误 总结：函数是 JavaScript 中最常用的作用域单元，默认声明在一个函数内部的变量会被隐藏，这是刻意为之的软件设计原则。但是函数并不是唯一的作用域单元。块作用域是指的变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{…}内部,想想命名空间啊骚年）。从 ES3 开始，try/catch 结构在 catch 分局中具有块作用域。ES6 引入了 let 关键字（var 的亲戚），用来在任意代码块中声明变量。块作用域的出现不仅仅是函数作用域的替代方案，能为我所用就好。（工具也是，不要纠结sublime还是atom还是vscode，虽然我最青睐两边！🙃）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[You Don't Know JavaScript(Chapter 1.1)]]></title>
      <url>%2F2017%2F03%2F14%2FYou-Don't-Know-JavaScript%2F</url>
      <content type="text"><![CDATA[JS 被广泛使用，它是支撑起网页内容交互体验的技术基础。JavaScript 极易上手，但是真正掌握的人却比较少。日常所用的仅仅是它的冰山一角。《你不知道的 JavaScript》（后文略写《本书》）所做的事情就是深入理解 JavaScript，尤其是难的那一部分。每次遇到 JavaScript 中出乎意料的部分时，能做到不去责怪语言，而是从中探究排除多样性，去理解 JavaScript 中“好的地方”，学会欣赏一门语言。 作用域 编译原理 “动态”，“解释执行”每个人都知道，但《本书》认为其实为一门编译语言（它不是提前编译的，编译结果也不能在分布式系统中进行移植）。 一般的编译器，其一段源代码执行前经历以下三步： 分词/词法分析（Tokenizing/Lexing） 解析/语法分析（Parsing Abstract Syntax Tree，“抽象语法树”） 代码生成（将 AST 转换为可执行的代码） 然而 JavaScript 引擎要复杂的多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，对冗余元素进行优化。大部分情况下编译发生在执行前的几微秒。在作用域背后，JavaScript 引擎使用了各种方法（JIT，延迟编译甚至重编译）来保证性能最佳。 理解作用域 处理程序的角色们： 引擎：负责JS程序编译以及执行 编译器：负责语法分析以及代码生成 作用域：收集并维护由所有声明的标识符组成的一系列查询，并实施一套严格的规则以确立访问权限 对话模拟： 变量的赋值操作过程 编译器变量(对象)查询的方式 LHS 查询（赋值目标的查询，找到他，并且把这个东西给他。） RHS 查询（取得目标源的值，得到某某的值。） 引擎与作用域的职责 作用域嵌套 作用域嵌套形成了作用域链，一旦在当前作用域无法查找到目标，就会向外传递（事件冒泡），直到最外层全局环境。 异常 为何区分 LHS 和 RHS 至关重要，因为在变量未声明的情况下，这两中查询行为是不一样的。 如果 RHS 查询是在所有作用域中遍寻不到所需要的变量，引擎就会抛出 ReferenceError 异常。 如果 LHS 查询子啊所有作用域中遍寻不到所需变量，就会在全局作用域中创建一个具有该名称的变量，并返回给引擎（非严格模式） 严格模式下，LHS 查询没找到变量同 RHS 一样抛出 ReferenceError 异常 严格模式下，RHS 查询找到目标变量，但对该变量的值进行不合理的操作，例如对非函数类型的值进行函数调用，引用 undefined 或者 null 类型的值中的属性，会抛出 TypeError（类型错误） ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功，找到了变量但是对结果的操作是非法或不合理的。 总结：作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。如果相对查找的变量进行赋值，那么就会用 LBS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 ‘=’ 操作符或调用函数是传入参数的操作都会导致关联作用域的赋值操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVC Backbone]]></title>
      <url>%2F2017%2F03%2F11%2FMVC-Backbone%2F</url>
      <content type="text"><![CDATA[最近阅读了《基于MVC的JavaScript web富应用开发》（后文简称《MVC》），文章第十二章介绍了 Backbone.js，再次激发了我对此框架的兴趣。在看这本书之前了解过 vue，也被其所吸引，而正如作者分享的经验， MVC 是 MV* 发展的前身。也因此让自己想要更加深入地去了解，MVC 到底是什么？借此从 Backbone 入手来学习这类库（框架）的设计思想。 Backbone 的特点 Backbone 是构建 JavaScript 应用程序的一个优秀类库，他的优美之处在于其简洁。这是一个轻量类库，覆盖了基础的功能，同时提供了最大的灵活性。（大小请参阅官方文件）MVC 是贯穿 Backbone 核心的模式。提供了模型、控制器和视图——骨架。Backbone 唯一以来 underscore.js，其提供非常有用的工具和 js 函数。除了 underscore，还可以使用 jQuery zepto 来提升 Backbone 处理视图的能力 引用来自《MVC》-chapter 12 知乎上关于 Backbone 的回答Backbone 最适合的应用场景是单页面应用，并且页面上有大量数据模型，模型之间需要进行复杂的信息沟通。Backbone 在这种场景下，能很好的实现模块间松耦合和事件驱动。 其他适用产品还有微博，网易微博的前端设计也是和 Backbone 类似的一个结构。 Backbone 的优点和一些经验 Tip： View 的划分将页面上的视图元素解耦，粒度细化。View 间通过事件和 Model 通讯，避免了 DOM 事件的滥用。Model 和 Restful 的通讯方式对于后端人员非常友好。 MVC 架构清晰， 我有个常年写 Java 没写过 JS 的同事看 Backbone 很快就了解了整体设计，虽然这时候他还是不会写 JS。 Collection/Model 抽象了以前杂乱的 AJAX 请求，CRUD 请求变得非常非常方便。 强烈建议 View -&gt; Model 单向依赖，世界会美好很多。 配上一个模块化加载器例如 SeaJS 会很爽。 Backbone 的一些缺点，或者说一些尚未实现的 Feature： Model 层比较简单，如果要支持 One-To-One 或者 One-To-Many 等复杂数据关系时有些力不从心。还有 一个 Model 只能属于一个 Collection 这个设计，页面复杂的时候会很受局限。例如这个问题： http://www.zhihu.com/question/19843899 （补充：Backbone.Relations 插件是这个问题的一个解决方案 https://github.com/PaulUithol/Backbone-relational By zjhiphop） 同上，Model 只有基本的 CRUD 操作，不能很好的扩展，Backbone.sync 方法写的不太灵活，要想扩展就得重写 sync 方法。 View 层没有很强的 Page 管理机制，比如通过 URL 切换改变整个页面时，页面上尚存的 View 如何处理？直接销毁的话，是否要销毁关联的 Model、Collection？Cache 住？如何管理 Cache？ 内存管理需要比较小心，缺乏机制避免创建重复 Model。 extends override 父类方法的时候得写一串的代码，就不能实现个 _super 方法么……（SuperClass.prototype.someMethod.apply） 对调试非常不友好。 作者有代码洁癖（也是加分项），this.$el 大家呼唤了这么久才加上，估计今生也看不到 this._super。更新慢。 总体来说 Backbone 还很轻，框架很漂亮但是有些细节还比较粗糙。用之前要做好对 Backbone 进行大量扩展甚至 Hack 的准备。 作者：pw来源：知乎 链接 模型1Backbone.Model 模型是保存应用程序数据的地方。可以想象为 APP 原始数据精心设计的抽象，并且添加了一些工具函数和事件。 模型和属性使用 set() 和 get() 来设置和获取实例中的属性。12var user = new User();user.set(&#123;name: "yevvb"&#125;);//hash 形式的表示对象 集合集合就是对模型实例的数据进行管理。文章中举了重建 twitter 关注和粉丝的例子，FOLLOWERS 和 FOLLOWEES，两者都是由 User 实例来填充数据，虽然来自于同一个 Model，但是包含了不同的 Model 实例（User 实例）。 控制集合内部顺序123456var Users = Backbone.Collection.extend(&#123; // 通过 comparator（） 函数来实现 comparator: function(user)&#123; return user.get("name"); &#125;&#125;); 视图Backbone 视图并不是模板本身，而是一些控制类。代表了一个 UI 逻辑块，负责一个简单的 DOM 的内容。比如说：控制元素的显隐，按钮的不同状态等等… 12345var UserView = Backbone.View.extend(&#123; el: $(&quot;.users&quot;)&#125;);new UserView(&#123;id: &quot;followers&quot;&#125;); 渲染视图每个视图都有一个 render() 函数，默认情况不做任何操作。一旦视图修改就需要 repaints，就应该调用此函数。模板可以依赖于其他工具 underscore 等等都可以。 即使是未插入到页面中去的 model 实例，其仍旧拥有自己的 el 元素，视图可在任何时候渲染，然后一次性插入到 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。 12345678var TodoView = Backbone.View.extend(&#123; template: _.template($(&quot;#todo-template&quot;).html()), render: function() &#123; $(this.el).html(this.template(this.model.toJSON())); // 返回以便于链式调用，非常重要 return this; &#125;&#125;); 委托事件事件必不可少，他是用户行为–交互的基础。 Backbone 视图提供了一种添加事件到 el 的快捷方法。12345678var TodoView = Backbone.View.extend(&#123; events: &#123; &quot;change input[type=checkbox]&quot; : &quot;toggleDone&quot;, &quot;click .destroy&quot; : &quot;clear&quot;, &#125;, toggleDone: function(e)&#123; /* ... */&#125;, clear: function(e)&#123; /* ... */&#125;&#125;); 绑定和上下文一旦视图发生改变，就会触发 change 事件，使得应用程序的视图和与之对应的模型数据是同步绑定的。而此时唯一需要注意的是 this 指示的上下文会发生变化。 控制器Backbone 的控制器将应用程序的状态和 URL 的 hash 片段关联在一起，使 URL 地址可分享，也可作为书签使用。本质上，控制器由一些路由和函数构成，当导航到这些路由时那些函数就会被调用。 123456789101112131415var PageController = Backbone.Controller.extend(&#123; routes: &#123; &quot;&quot;: &quot;index&quot;, &quot;help&quot;: &quot;help&quot;, // #help &quot;search/:query&quot;: &quot;search&quot;, // #search/kiwis &quot;search/:query/p:page&quot;: &quot;search&quot; // #search/kiwis/p7 &#125;, index: function()&#123; /* ... */ &#125;, help: function() &#123; // ... &#125;, search: function(query, page) &#123; // ... &#125;&#125;); 与服务器同步的问题第一次如何从服务器获取模型数据（fetch）服务器端如何存储如何自定义行为todo 应用实践 总结：backbone 为我们解耦了模型、视图和控制层，结构清晰简洁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
