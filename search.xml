<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS 节流与分时]]></title>
      <url>%2F2017%2F07%2F26%2FJS%E8%8A%82%E6%B5%81%2F</url>
      <content type="text"><![CDATA[通常我们提到性能优化，总是会忽略JS本身，因为事件触发的机制，有时候用户的未知操作可能会引起大量的函数、事件调用，虽然大多数情况是用户主动调用触发的，除非是函数本身实现不合理，否则我们一般不会遇到和性能相关的问题。在一些场景下，函数可能会被非常频繁地调用，从而造成大的性能问题。这里记录一下函数节流、事件节流，分时加载！ 触发场景 window.onresize 事件 mouseover 事件 用户输入触发 ajax 查询 上传进度 … 古董拍卖会 节流原理归结上述问题的共同点：函数被触发的频率太高。 例如在 window.onresize 事件中，浏览器默认1秒钟触发10次。而我们实际上只需要2次到3次。因此我们需要按时间段来忽略掉一些事件请求，例如确保在500ms内只打印一次。 借助 setTimeout 来完成。 函数节流window.onresize 12345678910111213141516171819202122232425262728293031323334353637383940/* * 将即将被执行的函数 fn 用 setTimeout 延迟一段事件执行 * 第一次 firstTime 触发，调用函数 * 上次调用 timer 还没执行，则忽略接下来的调用请求 * 需要一个时间间隔 interval */var throttle = function(fn, interval)&#123; var _self = fn, timer, firstTime = true, interval = interval || 500; return function()&#123; var args = arguments, _me = this; if(firstTime)&#123;_self.apply(_me, args);return firstTime = false; &#125; if(timer)&#123; return false; &#125; timer = setTimeout(function()&#123; clearTimeout(timer); timer = null; _self.apply(_me, args); &#125;, interval); &#125;;&#125;;window.onresize = throttle(function()&#123; console.log(1);&#125;, 500); 处理用户输入查询： 1234567891011121314151617181920/* * keyup 事件绑定处理程序 * 如果不设置节流，每次键盘输入都会调用函数 * 当用户输入停止后间隔200ms以上触发复杂的查询操作 * 这样做的目的（相比之下，定时器的设置与清除代价会小很多） */var textarea = document.getElementById('text')var timeoutIdtextarea.addEventListener('keyup', function() &#123; if(timeoutId) &#123; clearTimeout(timeoutId) &#125; timeoutId = setTimeout(function() &#123; // 在此触发 keyup 事件处理程序，注意绑定 context // 发送 ajax 查询等... &#125;, 200)&#125;) 分时函数函数节流是一种利用定时器来限制函数被频繁调用的解决方法。（试想一下拍卖会的场景） 还有一种情况是，单次调用时严重影响性能。（例如一次性渲染1000个dom节点） 123456789101112131415var arr = [];for (var i=1; i&lt;1000; i++)&#123; arr.push(i);&#125;var renderDomList = function(data)&#123; for (var i=0,l=data.length; i&lt;l; i++)&#123; var node = document.createElement('div') node.innerHtml = i; document.body.appendChild(node); &#125;&#125;renderDomList(arr); 使用分时函数的方式来改进 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 构建一个函数，让节点分批传入 * 创建节点的数据 arr * 创建节点的逻辑函数 fn * 每一批创建的数量 count = count || 8 */var timeChunk = function(arr, fn, count) &#123; var _arr, timer; var length = arr.length; var start = function() &#123; for (var i=0; i&lt; Math.min( count || 1, arr.length); i++) &#123; var _arr = arr.shift(); fn(_arr); &#125; &#125;; return function()&#123; timer = setInterval(function()&#123; if (arr.length === 0)&#123; return clearInterval( timer ); &#125; start(); &#125;, 200) &#125;&#125;// 创建测试var arr = [];for (var i=1; i&lt;1000; i++)&#123; arr.push(i);&#125;var renderDomList = timeChunk(arr, function( n )&#123; var node = document.createElement('div') node.innerHTML = n; document.body.appendChild(node);&#125;, 8)renderDomList(); 总结函数或事件节流与分时加载函数的区别在于，一个不是用户主动调用，另一个是用户主动发起的。 函数事件节流主要原理是：延迟函数的执行，如果该次延迟执行未完成，则忽略下次请求；或者延迟函数执行，一旦有新的请求，取消上次延迟队列，重新设置定时器，直到在特定条件下不再发起请求。 分时函数处理用户主动调用的函数，确保性能稳定的前提下，分时段执行函数，或将数据分段加载，执行函数依然不变，弱化函数执行对性能产生问题。 参考《JavaScript 设计模式与开发实践》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery--extend实现]]></title>
      <url>%2F2017%2F06%2F24%2FjQuery--extend%2F</url>
      <content type="text"><![CDATA[常见的面试问题，解读源码。（jQuery-2.0.3.js） 简单实现 extend。 extend() 的用法123456789$.extend( [deep], target, object1 [,objectN] )$.fn.extend( object )// 传入一个对象字面量，作为JQ插件的写法// 传入多个对象字面量，全部扩展到第一个对象中// 第一个传入布尔值 true，代表深拷贝，不传默认浅拷贝 注意 extend 的 this 对象123456789101112131415161718// jquery-2.0.3.js:285jQuery.extend = jQuery.fn.extend = func()&#123;&#125;;// 同一个方法，被两个对象引用，注意里面的区别var a = &#123; aaa: function()&#123; console.log('aaa'); &#125;, bbb: function()&#123; console.log('bbb'); &#125;&#125;;$.extend( a );// 这里 $.extend =&gt; this =&gt; $/jQuery =&gt; $.aaa()$.fn.extend( a );// 这里 $.fn.extend =&gt; this =&gt; $.fn/扩展实例 =&gt; $().aaa()// 区别就是一个扩展jQuery函数，一个是扩展jQuery对象方法(实例方法)// 只是这两者扩展调用的方法都指向同一个函数，实现方式差异不大 jQuery 中的实现逻辑123456789101112131415161718$.extend = $.fn.extend = function()&#123; // 定义一些变量 if()&#123;&#125; // 看是否为深拷贝 if()&#123;&#125; // 看看参数是否正确 if()&#123;&#125; // 看是否为插件 for()&#123; // 可能有多个对象的情况 if()&#123;&#125; // 防止循环引用 if()&#123;&#125; // 深拷贝 else if&#123;&#125; // 浅拷贝 &#125;&#125;; extend 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// jquery-2.0.3.js:285jQuery.extend = jQuery.fn.extend = function()&#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // 是否为深拷贝 if( typeof target === 'boolean' )&#123; deep = target; target = arguments[1] || &#123;&#125;; // skip the boolean and target i = 2; &#125; // 检查参数，如果既不是对象也不是函数而是字符串 if( typeof target !== "object" &amp;&amp; !jQuery.isFunction(target) )&#123; target = &#123;&#125;; &#125; // 如果只传入一个对象 if( length === i )&#123; target = this; --i; &#125; // 其他情况说明 for( ; i&lt;length; i++ )&#123; // 只处理不为空、undefined的值 if( (options = arguments[ i ]) != null )&#123; // 继承对象 for( name in options )&#123; src = target[ name ]; copy = options[ name ]; // 防止循环引用 if( target === copy )&#123; continue; &#125; // 深拷贝 if( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || ( copyIsArray = jQuery.isArray(copy) ) )&#123; if( copyIsArray )&#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // 不动原对象，直接复制，如果原对象也是数组或对象 target[ name ] = jQuery.extend( deep, clone, copy ); // don't bring undefined values &#125; else if ( copy !== undefined )&#123; // 浅拷贝 target[ name ] = copy; &#125; &#125; &#125; &#125; return target;&#125;; 简单实现 extend 函数浅拷贝es5中已经有 Object.assign()，大多数情况下，使用该方法。 深拷贝： 1234567891011121314151617181920212223242526// 类型判断方法var class2type = &#123;&#125;function type(obj) &#123; return obj == null ? String(obj) : class2type[toString.call(obj)] || "object"&#125;function isFunction(value)&#123; return type(value) == "function" &#125;function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window &#125;function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125;function isObject(obj) &#123; return type(obj) === "object" &#125;function isPlainObject(obj) &#123; return isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype&#125;var isArray = Array.isArray || function(object)&#123; return object instanceof Array&#125;function extend(target, source, deep) &#123; for (key in source) if (deep &amp;&amp; (isPlainObject(source[key])) || isArray(source[key])) &#123; if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125; if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = [] extend(target[key], source[key], deep) &#125; else if (source[key] !== undefined) target[key] = source[key]&#125; 测试一下 12345678var obj1 = &#123; iger: &#123;age: 30&#125;&#125;var obj2 = &#123; iger: &#123;sex: 'man'&#125;&#125;var obj3 = extend(obj1, obj2, true);console.log(obj3); 其他方式实现 12345// json 序列化和反序列化实现简单深拷贝var origin = &#123;"a": "aaa"&#125;var copy = JSON.parse(JSON.stringify(origin)) 继承 extend 小结jQuery 中使用的继承是拷贝继承 类式继承 通过 new 构造函数 原型继承 通过 {} 拷贝继承：用的更普遍，中括号运算符总能代替点运算符]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(4)--事件]]></title>
      <url>%2F2017%2F06%2F06%2FjQuery(4)--%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[JavaScript 核心API设计虽然简单，但是浏览器之间却严重不兼容，以致于客户端API过于复杂。jQuery 的设计思想 就是 ———— write less, do more. 简化通用操作，隐藏浏览器之间的差异，使得web开发变得更加简单。 jQuery处理事件处理事件一直有个难点就是IE9以下的事件API与其他浏览器都不相同。为了解决这个问题，jQuery实现了一个统一事件API，可工作在所有浏览器中（当然随着版本迭代，旧浏览器也逐步被抛弃）。 事件处理程序的简单注册1234//单机任意p段落时，改变背景色$("p").click(function() &#123; $(this).css("background-color", "gray") &#125;); 简单事件处理程序注册的方法： blur() focusin() mousedown() mouseup() change() focusout() mouseenter() resize() click() keydown() mouseleave() scroll() dbclick() keypress() mousemove() select() error() keyup() mouseout() submit() focus() load() mouseover() unload() 注意事项： focus和blur事件不支持冒泡，focusin和focusout支持。 mouseover和mouseout事件支持冒泡，mouseenter和mouseleave是非冒泡事件，解决前两者冒泡带来的问题。 resize和unload事件类型只在window对象中触发，应在$(window)对象上调用。 scroll()经常用于$(window)对象，但它也用于带滚动条的任何元素。 load()方法也能在$(window)上调用，用来给窗口注册加载事件处理程序，但最好还是将初始化函数传给$()。 error()方法可用于元素上，用来注册图片加载失败时调用的处理程序。 hover()用来给mouseenter和mouseleave注册处理程序。 hover(f,g)相当于调用mouseenter(f) &amp; mouseleave(g) toggle()将事件处理程序函数和单机事件绑定，可以指定多个函数。 toggle(f,g,h),第一次单击调用触发f()，第二次单击触发g()，以此类推。该方法在1.8版本中被弃用 事件注册的其他方法： 123456$("img", &#123; src: image_url, alt: img_description, className: "translucent_image", click: function()&#123; $(this).css("opacity","0"); &#125;&#125;) 需要注意的是，该方法中第二个参数任意一个属性与事件注册方法重名，就会被当做处理程序函数，并注册为命名事件类型的处理程序。 jQuery事件处理程序很多事件处理程序函数被当做是不带参数以及返回值的，但jQuery调用每一个事件处理程序是的确传入了一个或者多个参数，并且对处理程序的返回值进行了处理。 每一个事件处理程序都传入一个jQuery事件对象作为第一个参数。该对象的字段提供了与该事件相关的详细信息。 jQuery模拟标准Event对象，即使在不支持的标准事件对象的浏览器中（像IE8及其以下），jQuery事件对象在所有浏览器上不再拥有一组相同的字段。 jQuery事件处理程序的返回值始终有意义，如果返回false，与该事件相关联的默认行为，以及该事件接下来的冒泡都会被取消。也就是说，返回false等同于调用Event对象的preventDefault()和stopPropagation()方法。当返回一个值（非undefined）时，jQuery会将该值 存储在result属性 中，该属性可以诶后续调用的事件处理程序访问。 jQuery事件的对象jQuery通过定义自己的event对象来隐藏浏览器之间的实现差异。当一个jQuery事件处理程序被调用时，总会传入一个jQuery事件对象作为其第一个参数。jQuery复制了所有原生event对象到jQuery Event对象上： altKey ctrlKey newValue screenX attrChange currentTarget offsetX screenY attrName detail offsetY shiftKey bubbles eventPhase originalTarget srcElement button fromElement pageX target cancelable keycode pageY toElement charCode layerX prevValue view clientX layerY relatedNode wheelDelta clientY metaKey relatedTarget which 除了以上这些属性，Event对象还定义了下列方法： preventDefault() isDefaultPrevented() stopPropagation() isPropagationStopped() stopImmediatePropagation() isImmediatePropagationStopped() 需要注意的jQuery做了特殊处理的事件对象： metaKey pageX,pageY target,currentTarget,relatedTarget timeStamp which 还有以下jQuery自定义的特定于jQuery的对象： data：如果注册事件指定了额外的数据，处理程序可以用该字段访问 handler：当前正被调用的事件处理程序函数的引用 result：该事件最近调用的处理程序的返回值，忽略没有返回值的处理程序 originalEvent：浏览器生成的原生事件对象的引用 事件处理程序的高级注册.bind() 方法即为命名的事件绑定处理程序，该处理程序会绑定到jQuery对象的每一个元素上。直接使用bind()可以让我们使用事件注册的高级特性，这些特性在较简单的方法上是不可用的。 注：jQuery使用“bind”来表示事件处理程序的注册。ES5给函数定义了bind()方法，使用“bind”术语表示对象与函数之间的关联，这些函数会在这些对象上调用。Function.bind()方法的jQuery版本是一个名为jQuery.proxy()的工具函数。 12$('p').click(f);$('p').bind('click', f); 可以看到，bind()方法需要一个事件类型字符串作为其第一个参数，一个事件处理程序函数作为第二个参数。 jQuery允许传入三个参数，此时第一个参数仍为事件类型，第三个参数为事件处理函数，第二个参数为可以为任何值，jQuery会在调用处理程序前，将指定的值设置为event对象的data属性。通过这种方式传递额外的数据给处理程序，不需要使用闭包，有时非常有用。 bind()的其他特性： 123456789101112131415$('a').hover(f);$('a').bind('mouseenter mouseleave', f);// 两者等价，允许第一个参数由空格分隔事件类型// 处理程序会为每一个事件类型注册$('a').bind('mouseover.myMod', f);// 作为mouseover处理程序在命名空间myMod中把f绑定到所有元素$('a').bind('mouseout.myMod.yourMod', f)// 在命名空间‘myMod’和‘yourMod’中作为mouseout处理程序绑定 f// 允许为注册的事件处理程序指定命名空间$('a').hover(f, g)$('a').bind(&#123;mouseenter:f, mouseleave:g&#125;)// 两者等价// 第一个参数可以是对象，该对象吧事件名映射到处理程序函数 .one() 方法就和 .bind()方法一样，二者唯一的区别就是 one() 注册的事件处理器永远只会触发一次。 注销事件处理程序.unbind() 方法只可以用来注销使用bind()注册的事件处理程序，防止在将来的事件中被触发。 不带参数时，unbind()会注销jQuery对象中所有元素的（所有事件类型的）所有事件处理程序： 1234567891011121314151617181920212223242526$('*').unbind();// 从所有元素中移除所有jQuery事件处理程序$('a').unbind("mouseover mouseout");// 从所有a元素中取消绑定所有mouseover和mouseout处理程序$('a').unbind("mouseover.myMod mouseout.myMod");// 取消绑定在‘myMod’下所有的mouseover和mouseout处理程序$('a').unbind(".myMod");// 取消绑定在‘myMod’下所有的事件类型的处理程序$('a').unbind("click.ns1.ns2");// 同时取消绑定在‘ns1’和‘ns2’命名空间下的单机处理程序$("#muButton").unbind('click', myClickHandler);// 注销特定类型的事件处理程序函数，可用于传入3个参数的bind()$('a').unbind(&#123; mouseover: mouseoverHandler, mouseout: mouseoutHandler&#125;);// unbind()会轮询该对象，移除对应的事件类型处理程序函数unbind(ev);unbind(ev.type, ev.handler);// 以上两者等价，传递一个jQuery event给unbind()//他会自动取消传入事件的处理程序函数 触发事件当点击鼠标、键盘或触发其他时间类型时，注册的事件处理程序会自动调用。而有时我们需要手动触发…与很多jQuery方法同时用作getter和setter类似。 事件方法不带参数调用时：手动触发事件 带参数调用时：注册事件处理程序 当手动调用事件方法时，如果处理程序没有返回false或者调用事件对象的preventDefault()，实际上将会执行处理程序。需要注意的是，冒泡事件依然会冒泡！ 手动调用事件方法无法触发addEventListener()或者attachEvent()注册的事件处理程序。 .trigger()方法会在jQuery对象中的所有元素上触发为该类型事件注册的所有处理程序。 123456789101112131415161718192021222324252627$("#my_form").submit();$("#my_form").trigger("submit");// 两者等价，都是触发该事件// 但后者传入的字符串不能是多个事件类型$("button").trigger("click.ns1");// 触发某个命名空间下的click处理程序$("button").trigger("click!");// 触发没有命名空间的click处理程序$("#button1").click(function(e) &#123; $("#button2").trigger(e);&#125;);// 接受event对象（或者带有type属性的对象）为参数// btn1上的单击处理程序触发btn2上的相同事件$("#button1").trigger(&#123;type: 'click', synthetic: true&#125;);// 触发事件时，添加额外的属性给时间对象$("#btn1").click(function(e) &#123; if (e.synthetic) &#123;...&#125;;&#125;);// 检测额外属性来区分是否是真实事件还是虚假事件$("btn1").trigger("click", true);$("btn1").trigger("click", [x,y,z]);// 可以选择传入单一或者多个额外的参数 jQuery.event.trigger()该jQuery函数接受与.trigger()方法一样的参数，但在整个文档中触发指定事件类型的处理程序是更加高效。并且，以这种方法触发的全局事件不会冒泡，并且只会触发使用jQuery方法注册的处理程序。（不包括使用onclick等DOM属性注册的事件处理程序） 如果想调用事件处理程序，但是不执行默认操作，可以使用triggerHandler()替代trigger()。该方法和trigger()类似，除了会首先调用Event对象的preventDefault()和cancelBubble()方法。这意味着triggerHandler()方法手动触发的事件不会冒泡和触发默认行为。 自定义事件使用.bind()注册自定义事件的处理程序，使用.trigger()调用这些处理程序。 1234567$("#logoff").click(function() &#123;] $.event.trigger("logoff"); //广播事件 window.location = "logoff.php"; //导航到新页面&#125;);// 用户单机“logoff”按钮时，广播一个自定义事件// 给任何需要保存状态的感兴趣的观察者，然后导航到新页面 实时事件eg：比如动态添加到dom的日程，需要修改状态添加点击事件 使用.bind()给文档中所以a元素绑定了事件处理程序，接着又创建了带有a元素的新文档内容，这是新元素和老元素不会有相同的事件处理程序，行为将不一致。 .delegate() &amp; .undelegate() 通常在 $(document) 上调用，并传入一个jQuery选择器字符串、一个jQuery事件类型字符串以及一个jQuery事件处理程序函数。 1234$(document).delegate('a', "mouseover", linkHandler);// 使用bind()来处理文档静态部分// delegate()处理动态修改的部分 .live() &amp; .die() 也用来注册实时事件。live()相比delegete()更难理解，但是使用更普遍。 1234567$('a').live("mouseover", linkHandler);$("a", $(".dynamic")).live("mouseover", linkHandler);// 注意传给$()的参数x.live(type, handler);$(x.context).delegate(x.selector, type ,handler);// 对于jQuery对象x，上面两个方法所做事情相同。 在jQuery对象上调用live()方法时，该对象中的元素并没有起作用，真正起作用的是传递给$()方法的第一个参数选择器和第二个参数上下文，jQuery对象通过context和selector对象来使得这些值可用。通常不带第二个参数调用$()时，context对象是当前文档。 小结要学会事件，需要掌握事件基本类型，事件对象，注册方法以及如何注销事件，注册实时事件，自定义事件，掌握事件的触发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(3)--修改文档结构]]></title>
      <url>%2F2017%2F06%2F05%2FjQuery(3)--%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[JavaScript 核心API设计虽然简单，但是浏览器之间却严重不兼容，以致于客户端API过于复杂。jQuery 的设计思想 就是 ———— write less, do more. 简化通用操作，隐藏浏览器之间的差异，使得web开发变得更加简单。 插入和替换元素 操作 $(target).method(content) $(content).method(target) 目标元素结尾插入 append() appendTo() 目标元素起始插入 prepend() prependTo() 目标元素后插入 after() insertAfter() 目标元素前面插入 before() insertBefore() 替换目标元素 replaceWith() replaceAll() 12345678910111213141516171819202122232425262728293031323334353637$("#log").append("&lt;br/&gt;"+message);// 在#log元素结尾添加内容$("&lt;br/&gt;"+message).appendTo("#log");// 添加html到#log末尾中$("h1").prepend("§");// 在所有h1元素开头添加章节符号$(document.createTextNode("§")).prependTo("h1");// 给每个&lt;h1&gt;元素内起始处添加章节符号$("h1").before("&lt;hr/&gt;");// 在所有h1元素之前添加水平线$("&lt;hr/&gt;").insertBefore("h1");// 在每个h1元素之前插入水平线$("h1").after("&lt;hr/&gt;");// 在所有h1元素之后添加水平线$("&lt;hr/&gt;").insertAfter("h1");// 在每个h1元素之后插入水平线$("hr").replaceWirh("&lt;br/&gt;");// 将所有&lt;hr/&gt;元素替换为&lt;br/&gt;元素$("&lt;br/&gt;").replaceAll("hr");// 用&lt;br/&gt;替换所有的&lt;hr/&gt;$("h2").each(function() &#123; var h2 = $(this); h2.replaceWith("&lt;h1&gt;" + h2.html() + "&lt;h1/&gt;"); &#125;);// 将h2替换为h1，保持内容不变$("h1").map(function() &#123; return this.firstChild; &#125;).before("§");// 给每个&lt;h1&gt;之前添加章节标识// 以上方法都接受函数参数，用于计算需要插入的值。// 如果传入函数，每个选中元素都会调用该函数。// 同时，以上方法都找到对应的方法在内容上调用传入到目标元素。// 参考表格第三列。 复制元素.clone() 方法创建并返回每一个选中元素（包含元素的所有子孙）的一个副本。返回的jQuery对象还不是文档的一部分，然后可以使用前面的方法插入到文档中。 123456$(document.body).append("&lt;div id='linklist'&gt;&lt;/div&gt;");// 在文档结尾加入一个带有 linklist ID的新div$('a').clone().appendTo("#linklist");// 复制文档中所有链接并插入到该div中$("#linklist &gt; a").after("&lt;br/&gt;");// 给每个链接后面加个换行符号，独行显示 需要注意的是，.clone()方法并不会复制与元素相关的数据。如需要传入true参数。 包装元素 .wrap() 方法包装每一个选中元素。 .wrapInner() 方法包装每一个选中元素的内容。 .wrapAll() 方法将选中元素作为一组来包装。 通常传入一个新创建的包装元素或用来创建新包装元素的HTML字符串 这些方法接受函数作为参数，会在每个元素的上下文中调用一次，this指向该元素，索引是唯一参数，返回表示包装元素的字符串、element或jQuery对象。 12345678$("h1").wrap(document.createElement("i"));// 用&lt;i&gt;元素包装所有&lt;h1&gt;元素，产生&lt;i&gt;&lt;h1&gt;...&lt;h1/&gt;&lt;i/&gt;$("h1").wrap("&lt;div class='new' /&gt;");// 包装所有&lt;h1&gt;元素的内容，使用字符串参数更简单$("body&gt;p:first").wrap("&lt;a name='lead'&gt;&lt;div class='first'&gt;&lt;/div&gt;&lt;/a&gt;");// 将第一个段落包裹在一个锚点和div里$("body&gt;p:not(:first)").wrap(&lt;div class='resst'&gt;&lt;/div&gt;);// 将其他所有段落包裹在另一个div里 删除元素 .empty() 方法会删除每个选中元素的所有子孙节点（包括文本节点），但不会修改自身元素。 .remove() 方法会从文档中移除所选元素（及所有元素内容）。如果传入参数会被当做选择器，jQuery对象中只有匹配该选择器的元素才会被移除。（如果仅仅想从jQuery对象而非文档中移除，可以使用.filter()方法。）同时需要注意的是该方法会移除所有事件处理程序已经绑定数据。 .detach() 方法和 .remove()方法类似，但不会移除事件处理程序和数据。 .unwrap() 方法是 .wrap()或 .wrapAll()方法的反操作：移除每一个选中元素的父元素，不影响选中元素及其兄弟节点 小结文档节点的删除、增加、替换、包装的方法就这些，需要注意的是如何灵活使用它们。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(2)--getter&setter]]></title>
      <url>%2F2017%2F06%2F04%2FjQuery(2)--getter%26setter%2F</url>
      <content type="text"><![CDATA[JavaScript 核心API设计虽然简单，但是浏览器之间却严重不兼容，以致于客户端API过于复杂。jQuery 的设计思想 就是 ———— write less, do more. 简化通用操作，隐藏浏览器之间的差异，使得web开发变得更加简单。 getter &amp; setter 概要jQuery 最简单常见的操作是获取（get）和设置（set）HTML属性、CSS样式、元素内容和位置宽高。 jQuery 使用同一个方法既当getter用又做setter用，而不是定义一对方法。如果传入一个新值给该方法，则它设置此值，如果没有指定的值，则它返回当前值。 用做setter时，这些方法会给jQuery对象中的每一个元素设置值，然后返回该jQuery对象以方便链式调用。 用做getter时，这些方法只会查询元素集中的第一个元素，返回单个值。（如果要遍历所有元素，用map().）getter不会返回调用自身的jQuery对象，因此他只能出现在链式调用的末尾。 用作setter时，这些方法经常接受对象参数。在这种情况下，该对象的每一个属性都指定一个需要设置的名/值对。 用作setter时，这些方法经常接受函数参数。在这种情况下，会调用该函数来计算需要设置的值。调用该函数时的this对象是对应的元素，第一个参数是该元素的索引值，当前值则作为第二参数传入。（key,value） 获取和设置HTML属性.attr()方法：jQuery中用于HTML属性的getter/setter，他符合上面描述的概要理解中的每一条。attr()处理浏览器的兼容性和一些特殊情况，还让HTML属性名和JavaScript属性名可以等同使用（当二者存在差异时）。 12345678910111213141516171819$("form").attr("action"); // 获取第一个form元素的action属性$("#icon").attr("src","icon.gif"); // 设置src属性$("#banner").attr(&#123;src: "banner.gif", alt: "Advertisement", width: 720,height: 64&#125;); // 一次性设置4个属性$("a").attr("target", "_blank"); // 使所有链接在新窗口中打开$("a").attr("target", function()&#123; if (this.host == location.host) return "_self" else return "_blank";&#125;) // 非站内链接使用新窗口打开$("a").attr(&#123;target: function()&#123;...&#125;&#125;) // 可以像这样传入函数$("a").removeAttr("target"); // 让所有连接在本窗口中打开 获取和设置CSS属性.css() 方法和 .attr()方法很类似，只是 css() 方法作用于元素的CSS样式，而不是元素的HTML属性。注意这里的样式是单个样式而非复合样式，例如，无法获取’font’、’margin’，而应该获取’font-weight’,’font-family’,’margin-top’。 设置样式时，css() 方法会将样式简单添加到该元素的style属性中，css()方法允许使用连字符或者驼峰式JavaScript样式名。获取样式值时，css()会把数值转换成带有单位后缀的字符串返回。而在设置样式值的时候，则会将数值转换为字符串，所以必要时需要添加“px”后缀。 1234567891011121314151617181920$("h1").css("font-weight");// 获取第一个&lt;h1&gt;的字体重量$("h1").css("fontWeight");// 采用驼峰式的样式命名法则✘ $("h1").css("font");// ✘ 错误的示范，无法获取复合样式$("h1").css(&#123; "font-variant", "smallcaps"&#125;)；// 将样式设置在所有的&lt;h1&gt;元素上$("h1").css(&#123; "border", "2px solid #000"&#125;)// 设置复合样式是ok的$("h1").css(&#123;backgroundColor: "black", color: "white", fontVariant: "small-caps", padding: "10px 2px 2px 4px", border: "2px solid black"&#125;)// 可以一次性设置多个样式$("h1").css("font-size", function(i, curval)&#123; return Math.round(1.25*parseInt(curval));&#125;)// 让所有&lt;h1&gt; 字体大小增加 25% 获取和设置 CSS 类class 属性值（在JavaScript中通过 className 访问）会被解析成为一个由空格分隔的CSS类名列表。因此jQuery设计了一系列方法来操作列表，例如添加、删除某一项，或者判断一项是否在列表中，而不是替换整个列表。 .addClass():添加类.removeClass():删除类.toggleClass():当元素没有该类时添加，反之删除。该方法接受第二个参数 switch 布尔类型，用于样式是否应该被添加或者删除（addOrRemove）。从1.4开始，允许不传入参数，当没有参数时第一次调用会移除所有类，第二次重新添加。.hasClass():判断某类是否存在，只能接受单个类名作为参数，不支持函数参数 1234567891011121314151617181920212223242526272829303132333435363738$("h1").addClass("hilite");// 给所以元素添加类$("h1+p").addClass("hitile first");// 给&lt;h1&gt;后面的&lt;p&gt;元素添加多个类$("section").addClass(function(n)&#123; return "section" + n;&#125;);// 传递函数来添加自定义类$("div").removeClass();// 删除所有&lt;div&gt;元素中所有的类$("p").removeClass("hilite");// 删除所有&lt;p&gt;元素的hilite类$("p").removeClass("hilite first");// 一次删除多个类$("section").removeClass(function(n)&#123; return "section" + n;&#125;);// 传递函数来移除类$("tr:odd").toggleClass("oddrow");// 如果类不存在，就添加该类，存在则删除$("h1").toggleClass("big bold");// 一次切换两个类$("h1").toggleClass(function(n)&#123; return "big bold h1-" + n;&#125;);// 切换用函数计算出来的类$("h1").toggleClass("hitile", true);// 作用类似于 addClass$("h1").toggleClass("hitile", false);// 作用类似于 removeClass$("p").hasClass("first");// 判断是否所有&lt;p&gt;元素上都有该类？一次只能接受一个类$("#lead").is(".first");// 功能与上相同$("#lead").is(".first.hitile")// .is() 更加灵活 设置和获取HTML表单值.val() 方法用来设置和获取HTML表单元素的value属性，还可以获取和设置复选框、单选按钮以及\元素的选择状态。 12345678910111213141516$("#surname").val();// 获取surname文本域的值$("#usstate").val();// 从&lt;select&gt;获取单一值$("select#extras").val();// 从&lt;select multiple&gt;中获取一组值$("input:radio[name=ship]:checked").val();// 获取选中的单选按钮的值$("#email").val("Ivalid email address");// 给文本域设置值$("input:checkbox").val(["opt1","opt2"]);// 选中带有这些名字或值的复选框$("input:text").val(function()&#123; return this.defaultValue;&#125;)// 重置所有文本域的默认值 设置和获取元素内容.text() 和 .html()方法都是用来获取和设置元素的纯文本或HTML内容。.text() 不带参数调用时会返回所有匹配元素的子孙节点的文本内容。 .html() 不带参数调用时会返回第一个匹配元素的HTML的内容。x.html() 和 x[0].innerHTML一样高效。 如果传入字符串给.text()或.html()，该字符串会用作该元素的纯文本或格式化的HTML内容，它会替换掉所有存在的内容，和其他的setter方法一样，我们还可以传入函数，该函数用来计算出表示新内容的字符串： 12345678var title = $("head title").text()// 获取文档标题var headline = $("h1").html()// 获取第一个&lt;h1&gt;元素的html内容$("h1").text(function(n, current)&#123; return "§" + (n+1) + ": " + current&#125;)// 给每个标题添加章节符号 获取和设置元素位置宽高.offset() 可以获取或者设置元素的位置。该方法相对文档来计算位置值，返回一个对象，带有left和top属性，用老表示X和Y坐标。如果传入带有这些属性的对象给该方法，他会给元素设置指定的位置。必要时会设置CSS的position属性来使得元素可定位： 123456789var elt = $("#sprite"); // 需要移动的元素var position = elt.offset(); // 获取当前位置position.top += 100; // 改变Y坐标elt.offset(position); // 设置新位置// 将所有&lt;h1&gt;元素向右移动，移动的距离取决于他们在文档中的位置$("h1").offset(function(index,curpos)&#123; return &#123;left: curpos.left + 25*index, top: curpos.top&#125;;&#125;); .position() 方法很像.offset() 方法，但它只能用作getter，它返回的元素位置是相对于其偏移父元素的，而不是相对于文档。 jQuery对象的.offsetParent()方法:它返回第一个匹配元素用于定位的父节点。返回父元素中第一个其position设为relative或者absolute的元素。没有的话就是，此方法仅对可见元素有效。 .offset()返回元素的绝对位置，坐标相对于文档，而.position()则返回相对于元素的.offsetParent()的偏移量。 用于获取元素高度和宽度的getter都有三个。 .width() &amp; .height()返回宽度和高度，不含内边距、边框和外边距。.innerWidth() &amp; .innerHeight()则是包含内边距宽高。.outerWidth() &amp; .outerHeight()则是包含边框内边距的宽高。.outerWidth(true) &amp; .outerHeight(true)还包含外边距。 1234567891011var body = $("body");var contentWidth = body.width();var paddingWidth = body.innerWidth();var borderWidth = body.outerWidth();var marginWidth = body.outerWidth(true);var paddings = paddingWidth - contentWidth;// 左右内边距之和var borders = borderWdith - paddingWdith;// 左、右边框之和var margins = marginWdith - borderWidth;// 左右外边距之和 需要注意的是 .width() &amp; .height()方法的不对称性，这两个方法可以作为 getter和setter 使用，但是getter时返回的是不含内边距和边框的内容宽高，但是作为setter时他设置的是盒模型下css的width和height属性，可能包含内边距和边框。 box-sizing:content-box/border-box```123456789101112131415.scrollTop() &amp; .scrollLeft():可以获取或设置滚动条位置。这些方法可以用于Window对象或者Document元素上，当用在Document对象上时，会获取或设置存放该Document的window对象的滚动条位置，与其他setter不同的时，这两个方法不能接受函数作为参数。```javascript // 根据页面数 n 来滚动窗口，可以是分数或负数 function page(n) &#123; var w = $(window); // 将window封装为jQuery对象 var pagesize = w.height(); // 得到页面的高度 var current = w.scrollTop(); // 得到当前的滚动条位置 w.scrollTop(current + n*pagesize); // 设置新的滚动条位置 &#125;; 获取和设置元素数据jQuery定义了一个名为.data()的getter/setter方法，可以用来设置或者获取和文档元素、Document、window对象相关联的数据。（将数据与任意元素关联是很重要和强大的一项能力：这也是jQuery的事件处理程序注册和效果队列机制的基础，有时我们还会在自己的代码中使用.data()方法。） .removeData()方法用来从元素中删除数据。 12345678910111213$("div").data("x", 1);// 设置一些数据$("#mydiv").data("x");// 获取数据“x”的值$("div.nodata").removeData("x");// 删除一些数据$(el).data(...) // data的方法形式$.data(el, ...) // data的函数形式// 出于一些浏览器的限制，类似&lt;applet&gt;、// &lt;object&gt;、&lt;embed&gt;元素无法关联数据。 总结理论结合实践，通过科学的方法，合理的时间掌控来做到高效的学习。 番茄工作法、周期性复习 etc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery(1)--基础概念]]></title>
      <url>%2F2017%2F06%2F04%2FjQuery(1)--%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[JavaScript 核心API设计虽然简单，但是浏览器之间却严重不兼容，以致于客户端API过于复杂。jQuery 的设计思想 就是 ———— write less, do more. 简化通用操作，隐藏浏览器之间的差异，使得web开发变得更加简单。 jQuery 好在哪里 丰富强大的语法（CSS选择器），用来查询文档元素 高效的查询方法，用来找到与CSS选择器匹配的文档元素集 一套有用的方法，用来操作选中的元素 强大的函数式编程技巧，用来批量操作元素集，而不是每次操作单个 简单的语言用法，链式调用，表示一系列操作 jQuery 能做什么 查询并操作结果 设置HTML属性、CSS样式和类、HTML表单的值和元素内容、位置宽高、以及数据 改变文档结构：对元素进行插入、替换、包装和删除操作 跨浏览器时间模型 实现动画视觉效果 Ajax工具，用脚本发起http请求 工具函数 选择器的语法以及高级选择方法 编写插件扩展jQuery UI类库 jQuery 基础jQuery(): jQuery():这是jQuery类库定义的一个全局函数，$是别名。注意这是一个工厂函数，而不是构造函数，它返回一个新创建的对象，但是并没有和 new 一起使用。 四种调用方式 传入CSS选择器，返回当前文档中匹配的元素集 123- $() 简单的将传入的Element、Document或Window对象封装成jQuery对象并返回，使得可以使用jQuery方法来操作而非原生DOM方法 ```$(document) $(this) 传入HTML文本，根据传入的文本创建HTML元素并封装为jQuery对象返回，但是并不插入到文档中，但可以使用jQuery方法很方便的插入到你想要的位置。 img = $("", &#123; src: url,css: &#123;borderWidth: 5&#125;,click: handleClick&#125;);``` 第一个参数必须包含一个带有尖角括号的HTML标签，接受可选的第二参数，可以传递Document对象来指定与所创建元素相关联的文档。12- 传入一个函数，当文档加载完毕时且DOM可以操作时调用该函数。 ``` jQuery(function()&#123; //do something &#125;); ``` 老式的写法为 ``` $(document).ready(f) jQuery 术语jQuery 函数jQuery函数是 jQuery 或 $() 的值。该函数用来创建 jQuery 对象，用来注册 DOM 就绪时需要调用的处理程序，还用作 jQuery 的命名空间。 jQuery 对象jQuery对象是由jQuery函数返回的对象。一个jQuery对象表示一组文档元素，也叫做“jQuery结果”、“jQuery集” 或 “包装集”。 “选中元素”当传递CSS选择器给jQuery函数时返回的文档元素集。这里的“选中”是指CSS选择器。 jQuery 函数jQuery函数是指定义在jQuery命名空间中的函数，例如 jQuery.noConflict().也可以称为静态方法。 jQuery 方法jQuery方法是指由jQuery函数放回的jQuery对象的方法。是jQuery类库最重要和强大的部分。 区分 jQuery函数 和 jQuery方法 12345678// jQuery的each()函数用来// 对数组a中的每一个元素都调用一次函数f$.each(a,f);// 调用jQuery()函数获取表示文档中所以&lt;a&gt;元素的jQuery对象// 然后调用该jQuery对象的each()方法// 对选中的每一个元素调用一次函数f$('a').each(f); 唯一要区别的是jQuery函数和jQuery对象方法，搞清楚这里面的差异。 通常我们使用 $.each() 来表示 jQuery 函数，使用 .each() 来表示 jQuery 方法。 总结需要注意的是jQuery方法和jQuery函数的差别，以及jQuery对象的概念。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[How to Learning?]]></title>
      <url>%2F2017%2F05%2F04%2FLearning-How-to-Learn%2F</url>
      <content type="text"><![CDATA[标题是——学习如何学习。 没错，在最近看书时反复出现在脑海中的问题！幸运的是，我在 coursera 上面找到了我想要的答案！（如何学习） 学习之道，重要但是常为人所忽略，那些成功的人通常拥有属于自己的严谨的学习方式，他们成功的必然不是那些研究成果，而是他们学习的方法。 集中和发散思维大脑思考的方式很多，但主要有两种模式需要注意，集中模式（focus mode）和发散模式（diffuse mode）。前者需要集中心神、关注事物本身，后者需要以全局、其他的角度来思考问题。 事实上，在我们学习的时候，需要在不同的模式之前互相切换。但是，就像进程之间的上下文切换一样，都需要付出昂贵的成本。不同模式切换是非常困难的，所以就需要采用一些技巧来达成。 通常静坐、打盹、小憩都能让思维发散，达芬奇在此时会在手上拿着几个轴承滚珠，当自己睡着时，让滚珠掉落发出的声音来叫醒醒来！画家达利则是手拿一串钥匙。 拖延症、记忆和睡眠拖延症： 一旦某些事情曾经给你带来疼痛的感觉、或者是厌恶、不耐烦、抵触的情绪，那么你自然而然的就会默认将其优先级降低，甚至不去做他，转而去做那些能让你感到愉快，心情放松的事。 解决的办法就——番茄工作法🍅（Pomodoro） 设定任务顺序，规定完成时间。在完成之后给自己一些奖励，刷几分钟微博，看一会儿网站，打一会儿游戏。你需要的仅仅是一个番茄计时器和一张任务时间规划。通常 25-45 min是高效率完成一个小任务，同时能保持注意力集中的区间。 记忆概论：工作记忆&amp;长期记忆 当我们去记忆单词，回忆数学方程时我们使用的是大脑中的长期记忆。 然而，但我们想要将这些长期记忆用于日常生活，结合一些思维方法解决问题时，我们使用的则是工作记忆。 两种记忆互相关联，即时，有效率的处理问题使用的就是工作记忆，但是其容量非常有限（4 slots），所以我们需要使用间隔性重复来忽略工作记忆中的冗余信息，甚至将工作记忆存储为长期记忆。 睡眠在学习中的重要性 睡觉并不是一种浪费，当进入睡眠时，大脑细胞会收缩，细胞间隙增加一遍有毒物质排出。睡觉实际上是大脑保持清洁和健康的一种方式。 同时睡觉还是帮助你记忆和学习过程中很重要的一部分。所以在睡觉之前对所学进行复习，梦里就很有可能见到它。 总结理论结合实践，通过科学的方法，合理的时间掌控来做到高效的学习。 番茄工作法、周期性复习 etc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[性能测试和优化]]></title>
      <url>%2F2017%2F04%2F27%2Ftest-optimization%2F</url>
      <content type="text"><![CDATA[《YDKJS ASYNC&amp;PERFORMANCE》之中提到了代码性能和代码优化，在此先不谈论宏观程序架构级的性能表现，单从JS程序语言本身来思考！ 目标是弄清楚哪些种类的 JavaScript 性能更重要，哪些种类无关紧要，以及如何区分。 性能测试如何测试一端代码的运行速度？首先想到的肯定是计算运行时间： 1234567var strat = Date.now(); //or (new Date()).getTime()// some operatevar end = Date.now();console.log("duration:",(end - start)); 这可能是最想想到的办法，计算运行时间来判断，思路没有问题，但是运行过程受到测试环境、平台的定时器精度、引擎或者系统占用、引擎带来的优化等等诸多限制 所以上面的测试反馈几乎没有提供任何有用的信息，可能是一个特殊情况也不为人知，这样的低置信度的测试无法支撑任何决策。深入思考，解决问题，提出解决办法 重复 写一个循环，执行100次，计算得到每次执行的平均值？（那么一个异常值对平均値的影响是否可以忽略不计呢？） 不以固定次数运行，循环运行测试，直到某个固定时间？（运行多久，单次执行的若干倍？定时器的精度是否产生影响） 对此，可以将表现归纳为不正式！（不是不正式，是完全不知道:sad） Benchmark.js 可靠的测试应该是基于统计学上的合理实践。 Benchmark.js 就是一些聪明人编写的基于统计学上有效的性能测试工具。如何你要测试你的代码，用它就行了。（mocha 非常流行） 用 Benchmark.js 来运行一个快速的性能测试： 12345678910111213141516function() &#123; // something test here&#125;var bench = new Benchmark( "foo test",// 测试名称 foo,// 测试的函数内容 &#123; // 可选的额外内容 &#125;)bench.hz; // 每秒运算数bench.stats.moe; // 出错边界bench.stats.variance; // 样本方差// ... 这就是 benchmark.js 提供的 API。 对 Benchmark.js 还没有兴趣吗？快去看看文档 环境为王最新的科学研究表明可能人大脑可以处理的最快速度是 13ms，那么 20ns 的差别就是人类大脑感知间隙的 65 万分之一。单次运行下他们的差别就是没有差别。别忘了思考显示中连续运行 65 万次的可能性（😑） 引擎优化当你不知道引擎做了什么，所有的猜想和假设对于这样的决策不会有任何实际影响。但这并不是意味着测试毫无用处！ 测试不真实的代码只会产生不真实的结论，请根据实际测试实际而非无关紧要的代码，测试条件也要与期望的真实情况相接近。只要这样才能接近事实。 jsPerf.com测试需要根据业务实际的场景出发，模拟真实的环境。（桌面浏览器、移动设备等等） 完整性检查 写好测试 微性能 不是所有引擎都类似 大局出发（非关键路径上的优化是万恶之源） 尾调用优化：这是ES6要求的一种优化方法，它是 JavaScript 中原本不可能的一些递归模式变得实际。TCO 允许一个函数在结尾处调用另外一个函数来执行，不需要任何额外的资源。这意味着，对递归算法来说，引擎不再需要限制栈深度。 总结对一段代码进行有效的性能测试，特别是与同样代码的另外一个选择对比来看看哪种方案更快，需要认真处理细节。 直接使用测试库，但还是要注意编写测试时的问题。 勿要执迷微观细节而忽略了大局，避免落入不必要的陷阱。 尾调用优化（Tail Call Optimization, TCO）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 快速排序]]></title>
      <url>%2F2017%2F04%2F09%2F%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%8E%92%2F</url>
      <content type="text"><![CDATA[程序设计=算法+数据结构 引用这句话并不是想说其他，而是算法的重要性。慢慢来，先从基础算法–快排说起! 引用参考 阮一峰——快速排序（Quicksort）的Javascript实现排序动画演示 快速排序1. 在数据集之中，选择一个元素作为&quot;基准&quot;。 2. 所有小于&quot;基准&quot;的元素，都移到&quot;基准&quot;的左边；所有大于&quot;基准&quot;的元素，都移到&quot;基准&quot;的右边。 3. 对&quot;基准&quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 代码实现12345678910111213141516171819202122232425/* * @快排算法 * 找到基准，小的放左边，大的放右边 */function quickSort(arr) &#123; if(arr.length &lt;= 1) return arr var pivotIndex = Math.floor(arr.length/2); var pivot = arr.splice(pivotIndex,1)[0]; // console.log(arr); var left = []; var right = []; for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;console.log(quickSort([3,2,1,6,5,4,9,8,7,0])); 小结选基准 =&gt; 小的放左边 =&gt; 大的放右边 =&gt; 递归 =&gt; 长度为1则返回 结束才是真正的开始 《算法》有话要说快速排序 将数组排序的方式是：当两个子数组都有序时整个数组就自然有序；递归调用在处理整个数组之后；切分的位置取决于数组的内容。 归并排序 与快速排序互补：将数组分为两个子数组分别排序，并将有序的子数组归并以将整个数组排序；递归调用发生在处理整个数组之前；数组将会被等分。 快速排序的切分 对于某个 j， a[j] 已经排定 a[0] 到 a[j-1] 中所有元素都不大于 a[j] a[j+1,l-1] 中所有元素都不小于 a[j] 递归调用切分来排序 实现逻辑 先随意地取 a[0] 作为切分元素，定它的下标 从数组左端 i 开始向右扫描，找到一个 &gt; a[0] 的元素 从数组右端 j 开始向左扫描，找到一个 &lt;= a[0] 的元素 交换以上两个位置 如此继续，保证左指针的 i 左侧元素都不小于 a[0]， j 右侧都大于 a[0] 两指针相遇时，将切分元素 a[0] 和左数组最右侧元素交换，返回 j 12345678910function quickSort(arr, start, end)&#123; // 如果需要排序的数组内容长度小于1，跳出循环 // 对 arr[start]进行一次切分，并获得其排位顺序下标 j // 对 arr (start,j-1) &amp; (j+1,end) 递归调用切分&#125;function partition(arr, start, end)&#123; // 进行一次切分，对 arr[start] 进行切分 // 返回 arr[start] 的下标，因为该次切分总能确定它的顺序&#125; 演示代码 1234567891011121314151617181920212223242526272829303132333435363738function quickSort(arr, start, end)&#123; // 对用户输入做判断，柯里化 // 输入两个参数，对 arr[strat, length-1] 排序 // 输入一个参数，对 arr[0, length-1] 排序 if(end == null)&#123; end = arr.length -1 &#125; if(start == null)&#123; start = 0 &#125; if(end &lt;= start) return; var j = partition(arr, start, end); quickSort(arr, start, j-1); quickSort(arr, j+1, end);&#125;function partition(arr, start, end)&#123; var v = arr[start] var i = start var j = end + 1 while(true)&#123; while(arr[++i] &lt; v) if (i == end) break; while(arr[--j] &gt;= v) if (j == start) break; if(i &gt;= j) break; [arr[i], arr[j]] = [arr[j], arr[i]]; &#125; [arr[start], arr[j]] = [arr[j], arr[start]] return j&#125;// 测试一下，上述代码使用了ES6解构赋值，确保运行环境支持var a = [3,2,1,6,5,4,9,8,7,0]// 对数组部分内容进行排序quickSort(a, 3)console.log(a) // a =&gt; [3, 2, 1, 0, 4, 5, 6, 7, 8, 9]// 对所有内容进行排序quickSort(a)console.log(a) // a =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 值得深究的细节问题 原地切分：不要创建新的数组，这样在递归的切分方法中的开销会得不偿失。 别越界：小心扫描的指针不要跑出数组边界。（j==start）是多余的，a[start]不可能比自己小 保持随机性：就算你选择的切分元素，最好也是随机的，切分后的数组也打乱。 终止循环：正确检测越界需要一些技巧，终止循环要格外小心。 处理切分元素重复的情况：减少不必要的等值元素交换，避免运算时间为平方级别。 终止递归：保证切分元素放入正确的位置，当为最大最小值时需要注意。 算法改进改进意见 （小数组）切换到插入排序 三取样切分：使用子数组的一小部分元素的中位数来切分数组，测试发现这样效果最佳。还可以将取样元素放在数组末尾作为‘哨兵’来去掉 partition() 中的边界数组测试。 熵最优的排序：处理大量重复元素。例如一个元素全部重复的子数组，我们上面实现的快速排序还会继续将它切分为更小的数组。 解决办法 将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。这种切分实现比二分法更复杂，也有很多不同的解决办法。 E.W.Dijkstra 的荷兰国旗问题 Dijkstra 的解法 “三向切分的快速排序”： 从左到右，维护一个指针 lt 使得 arr[start…lt-1] 中的元素都小于 v 一个指针 gt 使得 arr[gt+1…end] 中的元素都大于 v 一个指针 i 使得 arr[lt…i-1] 中的元素都等于 v arr[i…gt] 中的元素都还未确定 开始时，i 和 start 相等，使用 comparable 接口对 a[i] 进行三向比较 a[i] &lt; v, 将 a[lt] 和 a[i] 交换，将 lt 和 i 加一 a[i] &gt; v, 将 a[gt] 和 a[i] 交换，将 gt 减一 a[i] = v, 将 i 加一 保证数组元素不变且缩小 gt - i 的值，循环才能结束 代码实现 12345678910111213141516171819202122232425262728293031323334353637function quick3way(arr, start, end)&#123; if(end &lt;= start) return; var lt = start, i = start + 1, gt = end; var v = arr[start]; while(i &lt;= gt)&#123; var cmp = compareTo(arr[i], v); if (cmp &lt; 0) &#123; [arr[lt], arr[i]] = [arr[i], arr[lt]] lt++ i++ &#125; else if(cmp &gt; 0) &#123; [arr[gt], arr[i]] = [arr[i], arr[gt]] gt-- &#125; else &#123; i++ &#125; // a[start..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..end] &#125; quick3way(arr, start, lt-1) quick3way(arr, gt+1, end)&#125;var compareTo = function compareTo(a, b)&#123; // 为了能够比较字母，转为字符串 a = a + '' b = b + '' return a.charCodeAt() - b.charCodeAt()&#125;// testvar b = ['E','A','S','Y','G','A','M','E']quick3way(b,0,7) // ["A", "A", "E", "E", "G", "M", "S", "Y"]var a = [1,2,3,1,2,3,1,2,3]quick3way(a, 0, 9) // [1, 1, 1, 2, 2, 2, 3, 3, 3] 上面的代码只实现了三向切分！ 总结快速排序的切分：一次切分能够至少确定一类重复元素的排序 一次排序之后重复调用切分，即递归发生在一次排序之后 原地切分：切分过程中没有创建新的数组对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YDKJS-this]]></title>
      <url>%2F2017%2F03%2F30%2FYDKJS4-this%2F</url>
      <content type="text"><![CDATA[this 在 JS 中是一个非常独特巧妙的存在，也是最复杂的机制之一，被定义在所有函数的作用域中（箭头函数除外）。即使是非常有经验的开发者也不一定能够说清楚到底 this 是什么（这句话我觉得不对O(∩_∩)O~）。 Arthur C.Clarke 说，任何足够先进的技术都和魔法无异。那么 this 有那么先进吗？ this 到底是什么呢？ why this this 隐式传递了一个对象的引用，显得更加优雅！同理，API 的设计会更加简洁且易于复用。同时，随着使用模式变得复杂，显示传递上下文会更加混乱，this 就是一种解决方案。 对 this 的两大误解 this 指向自身。 this 指向函数的作用域。（不完全错误） 作用域类似对象，但是无法通过代码来访问。所以 this 显然不指向作用域。 1234567function baz ()&#123; console.log(this.a);&#125;;var a = "global";baz(); // &lt;- global what’s thisthis 是在运行时进行绑定，他的上下文取决于函数调用时的各种条件。this 和函数编写时的位置并没有任何关系，只取决于函数的调用位置及方式。 当一个函数调用时，会创建一个活动记录（执行上下文），这个记录包含了函数在哪儿被调用（查找调用栈）、函数的调用方式、传入的参数等信息。 this 只是执行上下文的一个属性，指向该上下文。 调用位置寻找调用位置并非易事，某些编程模式可能会隐藏真正的位置。最重要的是分析调用栈（到达当前执行位置所调用的所有函数）。调用位置就是当前正在执行的函数的前一个调用中。 1234567891011121314151617181920212223242526var a = "global";function baz() &#123; // 当前调用栈 baz // 调用位置为全局作用域 console.log("baz"); bar(); // &lt;-- bar 的调用位置&#125;function bar() &#123; // 当前调用栈为 baz -&gt; bar // 调用位置为 baz 中 console.log("bar"); foo(); //&#125;function foo() &#123; // 当前调用栈为 baz -&gt; bar -&gt; foo // 调用位置为 bar 中 console.log("foo");&#125;baz(); // &lt;-- baz在全局被调用 this 绑定四大规则 默认绑定独立函数调用，无法应用其他规则是默认绑定 123456789// 严格模式下，不能将全局对象用于默认绑定function foo() &#123; "use strict"; console.log( this.a );&#125;var a = 2;foo(); // TypeError: this is undefined 此处有一个微小的细节，当 foo 运行在非 strict mode 下时，在严格模式下调用 foo() 则不影响默认绑定： 12345678910function foo() &#123; console.log( this.a );&#125;var a = 2;(function() &#123; "use strict"; foo(); // 2&#125;)(); 隐式绑定 调用位置是否有上下文，或者说是否被某个对象拥有或者包含。eg: obj.foo(); obj1.obj2.foo(); // &lt;– 第二个绑定到obj2当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。严格模式下可能会造成隐式丢失，this 可能为 undefined。传入回调函数也会造成隐式绑定。通过属性间接引用函数将 this 隐式绑定到当前对象上。 显式绑定 使用函数的 call(..) 和 apply(..) 方法。显示绑定依然无法解决绑定丢失问题。简单的辅助绑定函数： 123456// 简单的辅助函数function bind(fn, obj) &#123; return function() &#123; return fn.apply( obj, arguments ); &#125;&#125; ES5 内置的方法 Function.prototype.bind: 1234567891011function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a:2 &#125;;var bar = foo.bind( obj );var b = bar( 3 ); // 2 3console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，他会把你指定的第一个参数设置为 this 的上下文并调用原始函数，其余的参数传递给下层的函数（部分应用，是‘柯里化’的一种）。API 调用的上下文：第三方库以及 ES6 数组新的迭代方法，都支持传入一个可选的参数，通常称为上下文，其作用同 bind(..) 类似，这些函数实际上就是用过 call(..) 或者 apply(..) 实现了显式绑定。 硬绑定（new） 使用 new 操作符是，会创建一个新对象，并将函数调用中的 this 绑定到这个新对象上。具体操作如下： 创建/构造 一个全新的对象 这个新对象会被执行[[prototype]]连接 这个新对象会被绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象 优先级 是否在 new 中调用？（new 绑定） 是否通过 call、apply、bind 等调用？（显式绑定） 是否在某个上下文中调用？（隐式绑定） 都不是？（默认绑定） 凡事无绝对！被忽略的 this 将 null 或者 undefined 作为 this 的绑定对象传入 call、apply、bind 显式绑定规则时，这些值在调用时会被忽略，使用默认绑定规则。 更安全的 this 创建一个“DMZ”(demilitarized zone，非军事区)空的委托对象 ø 。 object.create(null) 比 {} 还空。（没有 Object.prototype 委托） 将 this 绑定到这个空对象，防止任何副作用保护全局对象。 间接引用 当有意无意的创建了一个函数的间接引用时，该函数会应用默认绑定。 12345678910function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 this 词法 ES6 定义了一种新的函数 箭头函数。这种函数不适用上述4种规则，而是根据外部作用域来决定 this，其本身并没有 this。 其原理同于 self = this 机制 更多关于箭头函数请看nodejs论坛的一片帖子——少年，不要滥用箭头函数啊 实现软绑定 可以默认绑定一个除全局对象和 undefined 以外的值，实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改 this 的能力： 1234567891011121314151617if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; // 这里的 this 是 Function.prototype 对象？ =&gt; √ var fn = this; // 捕获 curried 参数，即除指定对象之外的参数 var curried = [].slice.call( arguments, 1 ); var bound = function() &#123; return fn.apply( // 如果 this 绑定到全局对象或者 undefined，那么就把 指定的 obj 对象绑定到 this，否则就不修改 this (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); // 注意这里返回的是 bound 执行后的返回值 return bound(); &#125;;&#125; 请问上面的 this 会指向谁呢？思考运行时函数调用的位置以及对象！ 总结四大绑定规则，ES6 箭头函数！空对象 DMZ ø 创建！ this –&gt; 函数调用位置判断 –&gt; 调用栈 2017年7月10日 更新 《JavaScript设计模式与开发实践》 this： 函数是否作为对象的属性（隐式绑定） 函数作为普通函数被调用（默认绑定） 通过call、apply、bind调用（显式绑定） 通过new操作符实例化（new绑定） 箭头函数（上下文传递 =&gt; 这个应该加上） 回头再看上面的例子，试着套用规则！ 123456789 var obj = &#123; x: 10,fn: function() &#123; function f() &#123; console.log(this.x); // undefined &#125; f();&#125; &#125;; 这里的 f() 作为普通函数被调用，应用默认绑定，this 指向 window。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node 模块]]></title>
      <url>%2F2017%2F03%2F20%2FNode%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。 NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。 而我们都知道，除了最简单的 web 程序，所有的程序都需要数据库，而 node 生态中的数据库更多。所有主流关系型数据库（MySQL、MariaDB、PostgreSQL、Oracle、SQL Server）的接口都有，而 node 开发的出现带动了一种新式的数据库存储方式。“NoSQL 数据库”————《Node与Express开发》^1 Node 模块我们已经知道了闭包和模块的关系，让我们回顾一下模块模式的两个必要条件： 必须有外部的封闭函数，该函数至少被调用一次 封闭函数必须至少返回一个内部函数，这样内部函数才能在私有作用域中形成闭包，并访问或者修改私有状态。 需要注意的是 Node 模块和 npm 包管理是两个互相关联但又彼此不同的概念。 Node 模块：提供了一个模块化和封装的机制。 npm 包则提供了一种存储、版本化和引用项目（不限于模块）的标准范式。 1var express = require('express'); 这里的 require 是一个用来引入模块的 Node 函数。Node 默认会在目录 node_moudles 中寻找这些模块。而这里提到是 Node 自有模块的机制（不要在 node_moudles 中创建自己的模块）。 一般，我们会创建一个保存模块的目录。名字随意，但一半都称为 lib（library）。在此目录创建 fortune.js 12345678910111213// fortune.jsvar fortuneCookies = [ "Conquer your fears or they will conquer you.", "Rivers need springs.", "You will have a pleasant surprise.", "Whenever possible, keep it simple.",];exports.getFortune = function() &#123; var idx = Math.floor(Math.random() * fortuneCookies.length); return fortuneCookies[idx];&#125;; 在此注意全局变量输出的用法，如果需要对外暴露这个接口，需要手动挂载到 exports 上。在这个例子中，在模块外可以访问到函数 getFortune,但数组 fortuneCookies 是完全隐藏的。封装可以减少容易出错和比较脆弱的代码。 然后在你指定的 entry.js 入口文件中引入： 123// 引入 fortune.jsvar fortune = require('./lib/fortune.js'); 将 fortune.js 中的 exports 导出的方法放在 fortune 命名空间下。这里加载模块使用了相对路径，意思就是告诉 node 不要去 node_moudles 查找。然后你就可以用上面模块里的 getFortune 方法： 123app.get('/about', function(req, res) &#123; res.render('about', &#123; fortune: fortune.getFortune() &#125;);&#125;; commonJS &amp; ES6 moudlescommonJS 规范 &amp; ES6 模块参考阮一峰老师的文章 CommonJS 和 AMD/CMD 注释^1:“NoSQL 数据库”：这个否定的叫法或许不恰当，“文档数据库”或“键/值对数据库”也许更加合适。它们提供了一种概念上更简单的数据存储方式。这种数据库有很多，MongoDB 就是其中的佼佼者。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YDKJS-lambda]]></title>
      <url>%2F2017%2F03%2F17%2FYDKJS3-lambda%2F</url>
      <content type="text"><![CDATA[这章会是一个全新的闭包认知世界！在这之前，先回顾一下前面所说的一些名词，解析执行–编译器编译–词法化–作用域–词法作用域–函数作用域–块作用域–遮蔽效应–let–const。作用域的概念想必已经清楚了，我们都知道任何声明在某个作用域内的变量，都将附属于这个作用域，但是作用域同其中变量的位置又有何关系呢？ 还有什么是作用域闭包，闭包对垃圾回收又是如何影响的？闭包能用来干什么呢？以及闭包实现模块的多种方式（一定要深究，你会发现他会让你了解到插件管理、依赖加载、模块化开发形式实现、模块化规范AMD/CMD等等一大片新的海域） 提升先有声明还是先有赋值？ 123a = 2;var a;console.log(a); // 2 12console.log(b); // ReferenceErrorvar b = 2; 回顾我们的编译阶段，在代码执行 var a = 2时，引擎会对其进行编译。其中一部分工作就是找到所有的声明，并用何时的作用域将他们关联起来。 因此，所以变量和函数的声明都会在代码执行前（编译）时被处理，也就是编译阶段会将所有变量和函数声明关联到对应作用域顶端，这个现象我们叫做提升。 先有声明后有赋值，提升的现象出现在每一个作用域中。 1234567function foo() &#123; var a; console.log(a); // undefined a = 2;&#125;foo(); 可以看到 foo(…) 函数自身会对内部 var 进行提升，需要注意的是函数声明也会提升，而函数表达式却不会。 12345678foo(); // 不是 REFERENCEERROR 而是 TYPEERROR!bar(); // ReferenceErrorvar foo = function bar() &#123; console.log(1); // console.log(bar);&#125;// 因为赋值操作执行时处理，声明编译时处理。 即使这里使用了具名的标识符 bar，但是在赋值之前还是无法在当前作用域中使用,然而赋值后将指向改为 foo 函数优先 注意一个细节：在多个“重复”声明的代码中，是函数会首先被提升，然后才是变量。 同时，重复的 var 声明会被忽略，重复的函数声明则会被覆盖。 作用域闭包启示、重生（闭包） 本质上，闭包无处不在，其实基于词法作用域书写代码是产生的自然结果。（有点绕，只是还没有识别、拥抱和影响闭包的思维环境） 如果你觉得—-如果你感觉一句话里有闭包而且读不懂。（请把闭包换成引用） 不要把闭包想象成多少高大上的东西，它不过是一个能够记住并访问所在作用域的函数，当然你也可以在当前词法作用域之外去执行函数。 把闭包想像成一种思维方式，它无处不在，只是你还没有意识到它而已。 这不是新的语法或模式才能使用的工具。 闭包是基于词法作用域书写代码是产生的自然结果，你需要的就是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。 或许，这是种让你重新简化认识这个世界（JavaScript）的方式。 实质问题 说完了态度和概念，来看看闭包是如何呈现的： 123456789101112// eg.1？？？？？这是闭包吗？function foo() &#123; var a = 2; funtion bar() &#123; console.log( a ); // 2 是外部作用域 foo(...) 的变量的值 &#125; bar();&#125;foo (); 这是闭包吗？函数 bar() 可以访问外部作用域中的变量 a（这里不就是个 RHS 引用查询么？）。确切来说应该不是吧！ 这不就是词法作用域的查找规则么？ 问题来了，闭包难道不适用这些规则？实际上这些规则只是闭包的非常重要的一部分。 eg.1 只是一个涵盖了 foo() 作用域的闭包（当然往上到全局也行）。也可以认为 bar() 被封闭在 foo() 作用域中。 12345678910111213141516// eg.2function foo() &#123; var a = 2; function bar() &#123; console.log( a ); //2 &#125; return bar;&#125;var baz = foo();baz(); // 2 ————baz 是 foo() 执行后的返回函数的引用// baz() 相当于执行了该返回函数，也就是 bar() 函数。 在这个例子中， bar() 引用了 foo() 的 a，同时被 return 到了全局，被 baz() 在外部调用。 同时在 foo() 执行之后，引擎的垃圾回收通常会来释放不再使用的内存空间。foo() 看上去不再被使用，所以很自然的会考虑对齐进行回收。 而‘闭包’的左右就在这里，由于外部变量 baz 保持着对 bar() 的引用，这就导致了 foo() 的作用域没有被销毁，因为 bar() 本身还在使用。 由于 bar() 声明的位置在 foo() 内部，使得 foo() 的作用域一直存在，bar() 在之后的任何时间都可以进行引用。 这个引用就叫做闭包。 因此，在几微秒之后变量 baz 被实际调用（调用函数内部 bar），它可以访问 bar() 和 foo() 的作用域; 在这里，foo() 将 bar() 以返回值的形势传递给外部，同样可以使用其他方式： 123456789101112131415161718// eg.3function foo() &#123; var a = 2; function baz()&#123; console.log( a ); // 2 &#125; bar( baz ); // 传递给 bar，此时 fn = baz；&#125;function bar( fn )&#123; fn(); // 这也是闭包！&#125;foo();bar(); // 2 把内部函数 baz 传递给 bar，当调用这个内部函数时(fn),它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为他能够访问 a。 这个就是函数传递！（直接的哦） 1234567891011121314151617181920// eg.4var fn;function foo()&#123; var a = 2; function baz()&#123; console.log( a ); &#125; fn = baz; // 将 baz 分配给全局变量&#125;function bar()&#123; fn(); // 这就是闭包！ ‘就是个引用’&#125;foo();bar(); // 2 只要是闭包，就持有对原始定义作用域的引用，不管是用什么手段将内部函数传递到所在的词法作用域之外的。 只要执行这个函数就会使用闭包。 现在懂闭包这个概念了把！不懂的继续往下看12345678910// eg.5function wait(message)&#123; setTimeout( function timer()&#123; console.log( message ); &#125;, 1000);&#125;wait( "hello closure!" ); 将一个内部函数传递（timer）给 setTimeout(…)。 timer 具有涵盖了 wait(…) 作用域的闭包，因此还保留着对变量 message 的引用。 这里的 wait() 在执行1s后， setTimeout 会保持这对第一个参数的引用，这里是 timer，引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 深入到引擎的内部原理中，内置的工具函数setTimeout(..) 持有对一个参数的引用，这个参数也许叫作fn 或者func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的timer 函数，而词法作用域在这个过程中保持完整。 来看 jQuery 的例子： 1234567891011eg.6function setupBot(name, selector) &#123; $( selector ).click( function activator() &#123; console.log( "Activating: " + name ); &#125; );&#125;setupBot( "Closure Bot 1", "#bot_1" );setupBot( "Closure Bot 2", "#bot_2" ); jQuery 添加事件的写法。（这居然也是闭包，呵呵） 现在你懂了？（懵逼）本质上无论何时何地，如果将函数（访问他们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包（引用）在这些函数中的应用。 定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中、只要使用了 回调函数，实际上就是在使用闭包！ 来回顾下 1.3 中遗留的 IIFE 问题,为什么说 IIFE 是典型的闭包！（以及作者对此倍感争议） 12345eg.8var a = 2;(function IIFE() &#123; console.log( a );&#125;)(); 示例中的函数是在当前作用域执行的，并非在外部或者其他作用域执行。（这就是作者为什么认为这不算闭包，因为它只是在词法作用域规则下使用了 RHS 引用查询。说白了 a 不是闭包发现的，而是查找的到的。） 但是，IIFE 本身的确创建了闭包，而且也是最常用来创建可以被封闭起来的闭包的工具。 循环闭包处理事情的本身最重要的是你需要明白你在做什么，而不受他人影响。 说明闭包，常见的还是 for 循环的例子： 123456789101112eg.9for (var i=1; i&lt;=5; i++) &#123; setTimeout( function()&#123; console.log( i ); &#125;, i*1000 );&#125;// 过 1s 6 // 过 1s 6// 过 1s 6 // 过 1s 6 // 过 1s 6 这里的每次迭代过程中，第一个参数只是个什么都没有的空作用域。引擎处理这里的循环呢，只是那么一丁丁丁丁丁点儿时间，所有的定时器会形成一个队列，等到循环结束（i = 6）=&gt; 第一个定时器事件触发 =&gt; 第二个定时器事件触发 =&gt; 第三个定时器事件触发 =&gt; 第四个定时器事件触发 =&gt; 第五个定时器事件触发 因为作用域是空的，i 只能往上找，那么结果当然是 6 啊。 那么该如何改进呢，就是在循环的时候做手脚，把 i 存进该方法的作用域内，那么执行的时候自然就会正确输出！ 123456789eg.10for (var i=1; i&lt;=5; i++)&#123; (function() &#123; var j = i; setTimeout(function timer()&#123; console.log( j ); &#125;,j*500); &#125;)();&#125; 你当然可以把 i 作为参数传进去，设置默认的参数，这样就不需要 var j = i； 12345678eg.10-2for (var i=1; i&lt;=5; i++)&#123; (function(j) &#123; setTimeout(function timer()&#123; console.log( j ); &#125;, j*500); &#125;)( i );&#125; 这里的 j 你也可以叫 i，叫什么并不能影响它是 setTimeout(…) 作用域内的变量。 你还记得块作用域么？ 我们在这里使用 IIFE 每次都会创建新的作用域，这是 for 循环带来的。 也就是说，每次迭代我们都需要一个块作用域。那么为什么不用 let 声明，来劫持块作用域，并且在这个块作用域内声明一个变量。 1234567eg.11for (var i=1; i&lt;=5; i++) &#123; let j = i; //闭包的块作用域 setTimeout( function()&#123; console.log( j ); &#125;, j*1000 );&#125; 需要注意的是，for 循环头部的 let 声明还有一个特俗的行为。这个行为指出变量在循环过程中不止被声明一次，而是每次迭代都会进行声明。而随后的迭代都会使用上一个迭代结束的值来初始化这个变量，就他会 let j = 上个j ,然后 let j = i,那么我们知道变量的重复声明是无效的，仅仅赋值会生效;那么不就可以改了么 需要注意的是，这个行为是在 for 循环内的哦，如果你写到其他里面可能就不算了哦 123456eg.11for (let i=1; i&lt;=5; i++) &#123; setTimeout( function()&#123; console.log( i ); &#125;, i*1000 );&#125; 可以看到，闭包和块作用域联手，能填好多坑！ 模块闭包的强大威力不仅于此，还有一个就是模块。虽然看起来和闭包毫无干系！ 这个就有点懵了： 123456789101112eg.12function foo() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125;; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125;&#125; 在函数里面定义了 doSomething() 和 doAnother() 函数，而且内部引用了 foo() 的变量，也就是说 foo() 内部变量和函数的词法作用域（这就是闭包）也就是 foo() 的内部作用域。 函数也是对象（废话︿(￣︶￣)︽(￣︶￣)︿） 如果这样写就清楚了： 123456789101112131415161718192021222324eg.13function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 这里 CoolMoudle() 函数返回的是 json 对象（内部函数的引用，而保持内部数据变量隐藏且私有的状态）， foo 是该对象的引用，借此将内部函数暴露给了 foo 模块。如果不执行外部函数，内部作用域和闭包都无法被创建。 可以将这个对象类型的返回值看作“ 模块的公共 API” 常见的实现模块模式的方法通常被称作模块暴露。这里展示的是其变体。 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和$ 标识符就是jQuery 模块的公共API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。 模块模式的两个条件 必须要有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 上一个示例代码中的 CoolMoudle() 是独立的模块创建器，可以被调用任意多次，每次调用都会创建新的模块实例。对其改进来实现单例模式： 1234567891011121314151617var foo = (function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;)();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 模块函数被转换成 IIFE，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符 foo。 模块也是普通的函数，因此也可以接受参数； 123456789101112131415function CoolModule(id) &#123; function identify() &#123; console.log( id ); &#125; return &#123; identify: identify &#125;;&#125;var foo1 = CoolModule( "foo 1" );var foo2 = CoolModule( "foo 2" );foo1.identify(); // "foo 1"foo2.identify(); // "foo 2" 但是这里相当于生成了两个模块实例。 模块模式还有另一个简单而且强大的变化用法就是，为将要作为公共 API 返回的对象命名。 12345678910111213141516171819202122232425262728var foo = (function CoolModule(id) &#123; function change() &#123; // 修改公共API publicAPI.identify = identify2; &#125; function identify1() &#123; console.log( id ); &#125; function identify2() &#123; console.log( id.toUpperCase() ); &#125; var publicAPI = &#123; change: change, identify: identify1 &#125;; return publicAPI;&#125;)( "foo module" );foo.identify(); // foo modulefoo.change();foo.identify(); // FOO MODULE 模块实例的内部保留了对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。 现代的模块机制模块大多数依赖加载器或管理器。本质上是将这种模块定义的方法封装进一个友好的 API。来看一个例子视其核心： 123456789101112131415161718192021var MyMoudles = (function() &#123; var moudles = &#123;&#125;; function define(name, deps, impl) &#123; for (var i=0; i&lt;deps.length; i++) &#123; // 在这里取得模块的依赖 deps[i] = moudles[deps[i]]; &#125; // 这里是核心，保持对其他模块的引用 moudles[name] = impl.apply( impl, deps ); &#125; function get(name) &#123; return moudles[name]; &#125; return &#123; define: define, get: get &#125;&#125;)(); MyModules的define方法包含name，deps，impl三个参数; name表示是模块名称，deps表示是依赖项，impl表示实现。 关键是modules[name] = impl.apply( impl, deps ); 这一句，上面的for循环将一个模块名称数组先转成一个包含具体模块的数组，然后apply给具体的实现方法。相当于是注入了依赖项。 123456789101112131415161718192021222324252627282930313233// 定义2个模块，并测试引用包的依赖。MyModules.define( "bar", [], function() &#123; function hello(who) &#123; return "Let me introduce: " + who; &#125; return &#123; hello: hello &#125;;&#125; );MyModules.define( "foo", ["bar"], function(bar) &#123; var hungry = "hippo"; function awesome() &#123; console.log( bar.hello( hungry ).toUpperCase() ); &#125; return &#123; awesome: awesome &#125;;&#125; );var bar = MyModules.get( "bar" );var foo = MyModules.get( "foo" );console.log(bar.hello( "hippo" )); // Let me introduce: hippofoo.awesome(); // LET ME INTRODUCE: HIPPO 注意到定义foo模块的时候，依赖了bar模块，只需要在deps这个参数加入[“bar”]即可。 AMD 和 CMD 都是将模块的定义封装进一个友好的 API，就是 require.js 和 sea.js 中的 define 方法。上面的两个代码示例是一个现代模块实现 引申到其他，比如插件管理，依赖加载，API 统一管理等等（我也不知道对错，还是不太懂，需要深究） 但是上面的例子大致就是将依赖的其他此法作用域中的函数或者变量，封装进一个 API，保持对这些标识符的引用，这样我们就能够使用别人的方法或者工具。这其实就相当于闭包（这里使用了 apply 来保持对依赖的引用） 未来的模块机制其实说白了就是 ES6 的 moudle！ import &amp; export default import 可以将一个模块中的一个或多个API 导入到当前作用域中，并分别绑定在一个变量上。 module 会将整个模块的API 导入并绑定到一个变量上。 export 会将当前模块的一个标识符（变量、函数）导出为公共API。这些操作可以在模块定义中根据需要使用任意多次。 总结当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。 闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 模块有两个主要特征： 为创建内部作用域而调用了一个包装函数； （2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YDKJS-scope2]]></title>
      <url>%2F2017%2F03%2F16%2FYDKJS2-scope2%2F</url>
      <content type="text"><![CDATA[什么是词法化和词法作用域？ 你知道为什么不推荐 eval(…) 和 with 吗，以及这两者如何造成了性能下降的？ 什么是函数作用域？ 私有变量是怎么实现的？ 命名空间如何规避冲突？匿名函数的写法以及有点在哪儿？ ES6又是如何实现块作用域，babel 又是如何将其编译成兼容ES5的呢？ try/catch 仅仅用来调试吗？ 词法作用域回到编译器工作的第一个阶段，叫做词法化（单词化）。即对源代码中的字符进行检查，如果是有状态的解析过程，还会富裕单词意义。 词法作用域就是定义在词法阶段（查找标识符）的作用域。换句话说，就是在你写代码的时候你的变量和块作用域写在哪里，就决定了词法作用域的范围，这一切都是可以估量的（那么什么是不可预计的呢？），因此在词法分析阶段会保持作用域不变。（书写位置决定范围） 查找，作用域查找会在找到都一个匹配的标识符停止。在多层嵌套作用域中可以定义同名的标识符，这叫做遮蔽效应（内部遮蔽外部唯一吗？），查找由内而外。 备注：全局变量会自动成为全局对象（window、global）的属性，因此可以通过全局对象属性的引用来进行访问（对于被遮蔽的变量能够通过这种方式查到，但是仅限于全局变量，非全局则是被替换）。 欺骗词法 eval &amp; with eval: 我们经常动态插入代码，而引擎则会认为被 eval 插入的代码所处位置就是 eval 所处的作用域，这就导致了该词法作用域会在运行期间被修改（例如声明局部变量导致内容被替换等等）。 with：通常被当做重复引用一个对象中多个属性的快捷方式，问题就出在这里，万一里面包含了词法作用域内没有的属性或变量，那么就会造成全局污染（非严格模式下赋值查询的弊端）。需要注意的是，with 可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，同时将该对象的属性定义为词法作用域的词法标识符。 这两种方式都会造成词法解析过程的不确定性，因为无法对作用域查找进行优化，引擎会认为我做的这些都是白做的，最终的结果就是性能的严重下降，甚至是带来安全的隐患。 好消息是：严格模式下两者都被禁用了。 函数作用域和块作用域请把一个函数作用域想象成一个气泡（虽然不合理） 函数中的作用域 属于这个函数的全部变量都可以在整个函数的范围内使用以及复用（实际在嵌套的作用域中也可以访问）。这样的设计方案，充分利用了 JavaScript 变量可根据需要改变值类型的‘动态’特性。与此同时，意味着全局变量随时都能被任意位置访问，这就会带来意想不到的结果。 隐藏内部实现 123456789101112function doSomething(a) &#123; b = a + doSomethingElse( a * 2 ); console.log( b * 3）；&#125;function doSomethingElse(a) &#123; return a - 1;&#125;var b;doSomething( 2 ); // 15 这是一段原文中的例子，b 和 doSomethingElse 本该是 doSomething 的内部实现，然后因为写在函数外部，使得外部作用域拥有‘访问权限’，一旦被修改，那么我们就无法从 doSomething 得到我们预期想要的结果。这就是为何需要隐藏！ 先声明函数，然后在里面写代码是传统的思维。反过来思考，将一段代码挑选出来，用函数声明对其进行包装，实际上就相当于将代码隐藏了。于是就在这个代码片段周围新建了一个作用域气泡。（用作用域去隐藏一段代码，为什么要隐藏？） 软件设计的最小授权或最小暴露原则，指的是最小限度地暴露必要内容，而将其他内容都‘隐藏’起来，比如某个模块或对象的 API 设计。阻止部分访问，实现变量或函数的私有。 规避冲突 12345678910111213function foo() &#123; function bar(a) &#123; i = 3; //修改了 for 循环所属作用域中的 i console.log( a + i ); // a 为8，所以输出 11，但是 i 还是为3 &lt; 10 &#125; for (var i=0; i&lt;10; i++) &#123; console.log(i); // 3 + 1 = 4 bar( i * 2); //糟糕，无限循环了！因为声明会提前，赋值是运行到哪儿才会执行哪儿 &#125;&#125;foo() // 日志打印(4 11)无限循环; 看上面的例子，因为 bar 函数内部忘记声明变量 i（隐藏），导致全局创建了 i 变量，以致于污染了 for 循环（循环内var 会提到 foo的顶部，在执行 bar 时 i 被赋值，所以 i 始终为 3）。 前面我们提过‘遮蔽效应’，‘隐藏’作用域中的变量和函数带来的好处就是可以避免同名标识符之间的冲突。 全局命名空间：第三方库在实现过程中如果没有妥善地将内部私有函数和变量隐藏起来，那么就极易引发冲突（jQuery 的实现，$/jquery 的使用）。 模块管理：现代的模块机制，使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式导入到另外一个特定的作用域中（webpack 就是一个模块化打包工具，require/AMD/ES6 moudle 是规范）。 函数作用域 上面我们提到如何隐藏内部实现，通过包装函数来讲变量或者函数隐藏起来，但是这仍旧会生成一些具名函数（比如 foo()），这就意味着 foo 这个名字本身‘污染’了当前作用域。12345678(function foo() &#123; // &lt;-- 注意开头 （function... var a = 3; console.log(a); // 3&#125;)(); // &lt;-- 注意结尾 ...)()console.log( a ); //Uncaught ReferenceError: a is not defined 可以看到外部无法访问到 a 变量。 该包装函数声明以（function… 而不是以 function… 开始，函数会被当做函数表达式而不是一个标准的函数声明来处理。 !important &gt;&gt;&gt; 区分函数声明和表达式最简单的方法是看 function 关键字出现的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。(function foo() { .. }) 作为函数表达式意味着，foo 只能在 .. 所代表的位置中被访问，外部作用域作为无法访问，也就不会非必要的污染外部作用域。 匿名和具名 来看一个熟悉的场景：123setTimeout( function() &#123; console.log('blablabla')&#125;, 1000); 这个叫做匿名函数表达式，因为 function() {} 没有函数名，也就是名称标识符。函数表达式可以匿名，但是函数声明则不可以省略函数名————非法操作。 匿名函数表达式的缺点： 匿名函数在栈追踪不会显示出有意义的函数名，使得调试很困难。 没有函数名，当需要进行引用的时候只能用 过期的 arguments.callee 引用，例如递归，例如事件触发之后解除监听。 匿名函数省略了函数名，代码可读性变差。 解决办法：行内函数表达式————匿名和具名都对此无影响，解决了上述问题；1234// 最佳实践setTimeout( function timeoutHandler() &#123; console.log('blablabla')&#125;, 1000); 立即执行函数表达式 函数写在括号内变成了一个函数表达式，那么在后面加一对括号，就可以立即执行这个函数。 IIFE：（Immediately Invoked Function Expression）立即执行函数表达式 12345var a = 3;(function IIFE(a) &#123; console.log(a); &#125;)(2);console.log(a); // 3 另外一种写法，功能上一致，任凭喜好：12345var a = 3;(function IIFE(a) &#123; console.log(a); &#125;(2));console.log(a); // 3 IIFE 用法进阶： 1234567891011var a = 2;(function (global) &#123; var a = 3; console.log(a); //3 console.log(global.a); // 2 &#125;)(window);console.log(a); // 2 可以帮助你改进代码风格，使得对全局对象的引用变得比引用一个没有‘全局’资源的变量更加清晰（global.a 很明显是全局变量）。 还有一种常见的模式，就是参数默认为 undefined 1234567891011undefined = true; // 这里有坑(function IIFE( undefined ) &#123; var a; if (a === undefined) &#123; console.log("Undefined is safe here") &#125; &#125;)(); 目的是为了解决 undefined 标识符的默认值被错误覆盖导致的异常，这样的话即使在对于位置不传入任何值，内部的 undefined 还是 undefined。 IIFE 倒置代码运行顺序的用法（广泛用于 UMD 项目，其实看完会发现函数表达式内部会有一次调用参数（这里是传入进去的函数）的过程，参数（函数）会在这里执行）： 1234567891011121314151617181920212223var a = 2;console.log('one step');(function IIFE( def ) &#123; console.log('two step'); def( window ); console.log('three step');&#125;)(function def( global ) &#123; console.log('four step'); var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 console.log('five step');&#125;);// one step// two step// four step// 3// 2// five step// three step 这里让我想到了一个问题，操作符的优先级。MDN 上有介绍。 函数表达式 def 定义在片段的第二部分，然后当做参数（这个参数也叫做 def ）被传进 IIFE 函数定义的第一部分中。最后，参数 def （也就是传进去的函数）被调用，并将 window 传入当做 global 参数的值。 块作用域 函数作用域是 JS 中最普遍的作用域单元，但是其他类型也是存在的，而且实现维护起来可以更加优秀和简洁。 主要使用 JavaScript 开发的会对块作用域很陌生（非常赞同，以前甚至没有听过） 看个例子吧： 1234for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125;//你居然和我说这个就是块作用域？ 通常我们在 for 循环头部定义变量 i，事实上，我们只想在 for 循环内部的上下文使用它（没错=。=），而忽略了 i 会被绑定在外部作用域（函数或者全局）的事实（意思就是 for 循环不会像函数那样生成作用域气泡）。 再看一个例子： 1234567var foo = true;if (foo)&#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125; 同样是 if 条件，同样不会生成作用域气泡，那么你在里面使用 var，bar 最终还是属于外部作用域。这段代码只是为了可读性而可以伪装出的形式上的块作用域，如果用了，要确保没在其他地方使用 bar 只能靠自觉，这是不可取的。 with with 其实就是一个块左右的例子，因为他会单独生成一个作用域气泡，而且用 with 对象创建出的作用域仅在 with 声明中而非外部作用域中有效。 try/catch 很少人知道 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分局会创建一个块作用域。（我认为本书作者牛的地方就在这里，真的带你去了解任督二脉） 12345678910try &#123; undefined(); //执行一个非法操作来强制制造一个错误 err 用 undefined();&#125;catch( err ) &#123; console.log( err ); // TypeError: undefined is not a function&#125;console.log( err ); // ReferenceError: err is not defined 我们可以看到 err 仅在 catch 内部可以被访问，而在外部无法获得 undefined(); 来强制生成错误catch( err ){…}; 来捕获错误信息这个行为已经被标准化，除了IE其他浏览器大部分都已实现。但是当用一个作用域中的两个或者多个 catch 分句用同样的标识符名称声明错误变时，很多静态检查工具会发出警告。实际上我们知道因为 catch 实际上是块作用域，所以并不是重复定义变量，因为所以得变量都被安全的限制在 catch 块作用域内部。所以有人会命名 err1，err2 等等，有人则直接关闭静态检查工具对重复变量名的检查。这个其实很有用，因为能够帮助人们将 ES6 的一些新特性编译成能够兼容 ES5 的代码。 let 作业就是将变量绑定在 {…} 内部，同意 if 和 for 这些不会生成作用域气泡的条件语句也能够拥有自己私有的变量了。（想想还真是记得(≧▽≦)/！） 同样道理，直接将 let 写在 {…} 内部会隐式的将变量附加在一个块作用域上，如果没有密切关注，仍旧习惯性的移动就会导致代码混乱。解决办法就是认为添加一个显式的块： 123456789if foo &#123; &#123; // &lt;-- 显式的块 let bar = foo * 2; bar = something( bar ); console.log( bar ); &#125;&#125;console.log( bar ); // ReferenceError 垃圾回收 块作用域非常有用，这牵扯到闭包的垃圾回收机制相关。 这里留一个疑问？为什么闭包会导致垃圾无法及时回收呢？使用块作用域，能清楚的告知 JS 引擎，那些变量是使用一次后不再被使用的。 let 循环 12345for (let i=0; i&lt;10; i++) &#123; console.log( i ); // 1 2 3 4 5 6 7 8 9&#125;console.log( i ); // ReferenceError let 在 for 循环中的使用，实际上是将 i 绑定到了 for 循环的块中，而且是绑定到具体每一次循环迭代，确保使用上一个循环迭代结束时的值重新进行赋值。 12345678&#123; let j; for (let j=0; j&lt;10; j++) &#123; let i = j; console.log( i ); // 0 1 2 3 4 5 6 7 8 9 &#125;&#125;;console.log( j ); // RefeerenceError const const 同样用来可以创建作用域变量，但是其值为固定的（常量–&gt;如果是对象，那么固定的是其引用地址）。之后任何修改都会引起错误 总结：函数是 JavaScript 中最常用的作用域单元，默认声明在一个函数内部的变量会被隐藏，这是刻意为之的软件设计原则。但是函数并不是唯一的作用域单元。块作用域是指的变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{…}内部,想想命名空间啊骚年）。从 ES3 开始，try/catch 结构在 catch 分局中具有块作用域。ES6 引入了 let 关键字（var 的亲戚），用来在任意代码块中声明变量。块作用域的出现不仅仅是函数作用域的替代方案，能为我所用就好。（工具也是，不要纠结sublime还是atom还是vscode，虽然我最青睐两边！🙃）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YDKJS-scope]]></title>
      <url>%2F2017%2F03%2F14%2FYDKJS1-scope%2F</url>
      <content type="text"><![CDATA[《你不知道的 JavaScript》，遇见你还不太晚！ 作用域 编译原理 “动态”，“解释执行”每个人都知道，但《本书》认为其实为一门编译语言（它不是提前编译的，编译结果也不能在分布式系统中进行移植）。 一般的编译器，其一段源代码执行前经历以下三步： 分词/词法分析（Tokenizing/Lexing） 解析/语法分析（Parsing Abstract Syntax Tree，“抽象语法树”） 代码生成（将 AST 转换为可执行的代码） 然而 JavaScript 引擎要复杂的多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，对冗余元素进行优化。大部分情况下编译发生在执行前的几微秒。在作用域背后，JavaScript 引擎使用了各种方法（JIT，延迟编译甚至重编译）来保证性能最佳。 理解作用域 处理程序的角色们： 引擎：负责JS程序编译以及执行 编译器：负责语法分析以及代码生成 作用域：收集并维护由所有声明的标识符组成的一系列查询，并实施一套严格的规则以确立访问权限 对话模拟： 变量的赋值操作过程 编译器变量(对象)查询的方式 LHS 查询（赋值目标的查询，找到他，并且把这个东西给他。） RHS 查询（取得目标源的值，得到某某的值。） 引擎与作用域的职责 作用域嵌套 作用域嵌套形成了作用域链，一旦在当前作用域无法查找到目标，就会向外传递（事件冒泡），直到最外层全局环境。 异常 为何区分 LHS 和 RHS 至关重要，因为在变量未声明的情况下，这两中查询行为是不一样的。 如果 RHS 查询是在所有作用域中遍寻不到所需要的变量，引擎就会抛出 ReferenceError 异常。 如果 LHS 查询子啊所有作用域中遍寻不到所需变量，就会在全局作用域中创建一个具有该名称的变量，并返回给引擎（非严格模式） 严格模式下，LHS 查询没找到变量同 RHS 一样抛出 ReferenceError 异常 严格模式下，RHS 查询找到目标变量，但对该变量的值进行不合理的操作，例如对非函数类型的值进行函数调用，引用 undefined 或者 null 类型的值中的属性，会抛出 TypeError（类型错误） ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功，找到了变量但是对结果的操作是非法或不合理的。 总结：作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。如果相对查找的变量进行赋值，那么就会用 LBS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 ‘=’ 操作符或调用函数是传入参数的操作都会导致关联作用域的赋值操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVC Backbone]]></title>
      <url>%2F2017%2F03%2F11%2FMVC-Backbone%2F</url>
      <content type="text"><![CDATA[最近阅读了《基于MVC的JavaScript web富应用开发》（后文简称《MVC》），文章第十二章介绍了 Backbone.js，再次激发了我对此框架的兴趣。在看这本书之前了解过 vue，也被其所吸引，而正如作者分享的经验， MVC 是 MV* 发展的前身。也因此让自己想要更加深入地去了解，MVC 到底是什么？借此从 Backbone 入手来学习这类库（框架）的设计思想。 Backbone 的特点 Backbone 是构建 JavaScript 应用程序的一个优秀类库，他的优美之处在于其简洁。这是一个轻量类库，覆盖了基础的功能，同时提供了最大的灵活性。（大小请参阅官方文件）MVC 是贯穿 Backbone 核心的模式。提供了模型、控制器和视图——骨架。Backbone 唯一以来 underscore.js，其提供非常有用的工具和 js 函数。除了 underscore，还可以使用 jQuery zepto 来提升 Backbone 处理视图的能力 引用来自《MVC》-chapter 12 知乎上关于 Backbone 的回答Backbone 最适合的应用场景是单页面应用，并且页面上有大量数据模型，模型之间需要进行复杂的信息沟通。Backbone 在这种场景下，能很好的实现模块间松耦合和事件驱动。 其他适用产品还有微博，网易微博的前端设计也是和 Backbone 类似的一个结构。 Backbone 的优点和一些经验 Tip： View 的划分将页面上的视图元素解耦，粒度细化。View 间通过事件和 Model 通讯，避免了 DOM 事件的滥用。Model 和 Restful 的通讯方式对于后端人员非常友好。 MVC 架构清晰， 我有个常年写 Java 没写过 JS 的同事看 Backbone 很快就了解了整体设计，虽然这时候他还是不会写 JS。 Collection/Model 抽象了以前杂乱的 AJAX 请求，CRUD 请求变得非常非常方便。 强烈建议 View -&gt; Model 单向依赖，世界会美好很多。 配上一个模块化加载器例如 SeaJS 会很爽。 Backbone 的一些缺点，或者说一些尚未实现的 Feature： Model 层比较简单，如果要支持 One-To-One 或者 One-To-Many 等复杂数据关系时有些力不从心。还有 一个 Model 只能属于一个 Collection 这个设计，页面复杂的时候会很受局限。例如这个问题： http://www.zhihu.com/question/19843899 （补充：Backbone.Relations 插件是这个问题的一个解决方案 https://github.com/PaulUithol/Backbone-relational By zjhiphop） 同上，Model 只有基本的 CRUD 操作，不能很好的扩展，Backbone.sync 方法写的不太灵活，要想扩展就得重写 sync 方法。 View 层没有很强的 Page 管理机制，比如通过 URL 切换改变整个页面时，页面上尚存的 View 如何处理？直接销毁的话，是否要销毁关联的 Model、Collection？Cache 住？如何管理 Cache？ 内存管理需要比较小心，缺乏机制避免创建重复 Model。 extends override 父类方法的时候得写一串的代码，就不能实现个 _super 方法么……（SuperClass.prototype.someMethod.apply） 对调试非常不友好。 作者有代码洁癖（也是加分项），this.$el 大家呼唤了这么久才加上，估计今生也看不到 this._super。更新慢。 总体来说 Backbone 还很轻，框架很漂亮但是有些细节还比较粗糙。用之前要做好对 Backbone 进行大量扩展甚至 Hack 的准备。 作者：pw来源：知乎 链接 模型1Backbone.Model 模型是保存应用程序数据的地方。可以想象为 APP 原始数据精心设计的抽象，并且添加了一些工具函数和事件。 模型和属性使用 set() 和 get() 来设置和获取实例中的属性。12var user = new User();user.set(&#123;name: "yevvb"&#125;);//hash 形式的表示对象 集合集合就是对模型实例的数据进行管理。文章中举了重建 twitter 关注和粉丝的例子，FOLLOWERS 和 FOLLOWEES，两者都是由 User 实例来填充数据，虽然来自于同一个 Model，但是包含了不同的 Model 实例（User 实例）。 控制集合内部顺序123456var Users = Backbone.Collection.extend(&#123; // 通过 comparator（） 函数来实现 comparator: function(user)&#123; return user.get("name"); &#125;&#125;); 视图Backbone 视图并不是模板本身，而是一些控制类。代表了一个 UI 逻辑块，负责一个简单的 DOM 的内容。比如说：控制元素的显隐，按钮的不同状态等等… 12345var UserView = Backbone.View.extend(&#123; el: $(&quot;.users&quot;)&#125;);new UserView(&#123;id: &quot;followers&quot;&#125;); 渲染视图每个视图都有一个 render() 函数，默认情况不做任何操作。一旦视图修改就需要 repaints，就应该调用此函数。模板可以依赖于其他工具 underscore 等等都可以。 即使是未插入到页面中去的 model 实例，其仍旧拥有自己的 el 元素，视图可在任何时候渲染，然后一次性插入到 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。 12345678var TodoView = Backbone.View.extend(&#123; template: _.template($(&quot;#todo-template&quot;).html()), render: function() &#123; $(this.el).html(this.template(this.model.toJSON())); // 返回以便于链式调用，非常重要 return this; &#125;&#125;); 委托事件事件必不可少，他是用户行为–交互的基础。 Backbone 视图提供了一种添加事件到 el 的快捷方法。12345678var TodoView = Backbone.View.extend(&#123; events: &#123; &quot;change input[type=checkbox]&quot; : &quot;toggleDone&quot;, &quot;click .destroy&quot; : &quot;clear&quot;, &#125;, toggleDone: function(e)&#123; /* ... */&#125;, clear: function(e)&#123; /* ... */&#125;&#125;); 绑定和上下文一旦视图发生改变，就会触发 change 事件，使得应用程序的视图和与之对应的模型数据是同步绑定的。而此时唯一需要注意的是 this 指示的上下文会发生变化。 控制器Backbone 的控制器将应用程序的状态和 URL 的 hash 片段关联在一起，使 URL 地址可分享，也可作为书签使用。本质上，控制器由一些路由和函数构成，当导航到这些路由时那些函数就会被调用。 123456789101112131415var PageController = Backbone.Controller.extend(&#123; routes: &#123; &quot;&quot;: &quot;index&quot;, &quot;help&quot;: &quot;help&quot;, // #help &quot;search/:query&quot;: &quot;search&quot;, // #search/kiwis &quot;search/:query/p:page&quot;: &quot;search&quot; // #search/kiwis/p7 &#125;, index: function()&#123; /* ... */ &#125;, help: function() &#123; // ... &#125;, search: function(query, page) &#123; // ... &#125;&#125;); 与服务器同步的问题第一次如何从服务器获取模型数据（fetch）服务器端如何存储如何自定义行为todo 应用实践 总结：backbone 为我们解耦了模型、视图和控制层，结构清晰简洁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读书做笔记]]></title>
      <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[hi，这里是叶文斌的博客。自认不聪明，说笨不足说懒有余。 这博客的目的只有一个，看一本书，就照着书本把精华抄下来。 时而看看。顺便改改懒惰的习惯！]]></content>
    </entry>

    
  
  
</search>
