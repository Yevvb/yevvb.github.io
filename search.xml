<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[You don't know JavaScript(Chapter 2)]]></title>
      <url>%2F2017%2F03%2F30%2FYou-Don't-Know-Javascript4%2F</url>
      <content type="text"><![CDATA[this 在 JS 中是一个非常独特巧妙的存在，也是最复杂的机制之一，被自动定义在所有函数的作用域中（箭头函数除外）。即使是非常有经验的开发者也不一定能够说清楚到底 this 是什么（这句话我觉得不对O(∩_∩)O~）。 Arthur C.Clarke 说，任何足够先进的技术都和魔法无异。那么 this 有那么先进吗？ why this this 隐式传递了一个对象的引用，显得更加优雅！同理，API 的设计会更加简洁且易于复用。同时，随着使用模式变得复杂，显示传递上下文会更加混乱，this 就是一种解决方案。 对 this 的两大误解 this 指向自身。 this 指向函数的作用域。（不完全错误） 作用域类似对象，但是无法通过代码来访问。所以 this 显然不指向作用域。 1234567function baz ()&#123; console.log(this.a);&#125;;var a = "global";baz(); // &lt;- global what’s thisthis 是在运行时进行绑定，他的上下文取决于函数调用时的各种条件。this 和函数编写时的文职并没有任何关系，只取决于函数的调用位置及方式。 当一个函数调用时，会创建一个活动记录（执行上下文），这个记录包含了函数在哪儿被调用（查找调用栈）、函数的调用方式、传入的参数等信息。 this 只是执行上下文的一个属性，指向该上下文。 调用位置寻找调用位置并非易事，某些编程模式可能会隐藏真正的位置。最重要的是分析调用栈（到达当前执行位置所调用的所有函数）。调用位置就是当前正在执行的函数的前一个调用中。 1234567891011121314151617181920212223242526var a = "global";function baz() &#123; // 当前调用栈 baz // 调用位置为全局作用域 console.log("baz"); bar(); // &lt;-- bar 的调用位置&#125;function bar() &#123; // 当前调用栈为 baz -&gt; bar // 调用位置为 baz 中 console.log("bar"); foo(); //&#125;function foo() &#123; // 当前调用栈为 baz -&gt; bar -&gt; foo // 调用位置为 bar 中 console.log("foo");&#125;baz(); // &lt;-- baz在全局被调用 this 绑定四大规则 默认绑定独立函数调用，无法应用其他规则是默认绑定 123456789// 严格模式下，不能将全局对象用于默认绑定function foo() &#123; "use strict"; console.log( this.a );&#125;var a = 2;foo(); // TypeError: this is undefined 此处有一个微小的细节，当 foo 运行在非 strict mode 下时，在严格模式下调用 foo() 则不影响默认绑定： 12345678910function foo() &#123; console.log( this.a );&#125;var a = 2;(function() &#123; "use strict"; foo(); // 2&#125;)(); 隐式绑定 调用位置是否有上下文，或者说是否被某个对象拥有或者包含。eg: obj.foo(); obj1.obj2.foo(); // &lt;– 第二个绑定到obj2当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。严格模式下可能会造成隐式丢失，this 可能为 undefined。传入回调函数也会造成隐式绑定。通过属性间接引用函数将 this 隐式绑定到当前对象上。 显式绑定 使用函数的 call(..) 和 apply(..) 方法。显示绑定依然无法解决绑定丢失问题。简单的辅助绑定函数： 123456// 简单的辅助函数function bind(fn, obj) &#123; return function() &#123; return fn.apply( obj, arguments ); &#125;&#125; ES5 内置的方法 Function.prototype.bind: 1234567891011function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a:2 &#125;;var bar = foo.bind( obj );var b = bar( 3 ); // 2 3console.log( b ); // 5 bind(..) 会返回一个硬编码的新函数，他会把你指定的第一个参数设置为 this 的上下文并调用原始函数，其余的参数传递给下层的函数（部分应用，是‘柯里化’的一种）。API 调用的上下文：第三方库以及 ES6 数组新的迭代方法，都支持传入一个可选的参数，通常称为上下文，其作用同 bind(..) 类似，这些函数实际上就是用过 call(..) 或者 apply(..) 实现了显式绑定。 硬绑定（new） 使用 new 操作符是，会创建一个新对象，并将函数调用中的 this 绑定到这个新对象上。具体操作如下： 创建/构造 一个全新的对象 这个新对象会被执行[[prototype]]连接 这个新对象会被绑定到函数调用的 this 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象 优先级 是否在 new 中调用？（new 绑定） 是否通过 call、apply、bind 等调用？（显式绑定） 是否在某个上下文中调用？（隐式绑定） 都不是？（默认绑定） 凡事无绝对！被忽略的 this 将 null 或者 undefined 作为 this 的绑定对象传入 call、apply、bind 显式绑定规则时，这些值在调用时会被忽略，使用默认绑定规则。 更安全的 this 创建一个“DMZ”(demilitarized zone，非军事区)空的委托对象 ø 。 object.create(null) 比 {} 还空。（没有 Object.prototype 委托） 将 this 绑定到这个空对象，防止任何副作用保护全局对象。 间接引用 当有意无意的创建了一个函数的间接引用时，该函数会应用默认绑定。 12345678910function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 this 词法 ES6 定义了一种新的函数 箭头函数。这种函数不适用上述4种规则，而是根据外部作用域来决定 this，其本身不没有 this。 其原理同于 self = this 机制 更多关于箭头函数请看nodejs论坛的一片帖子——少年，不要滥用箭头函数啊 实现软绑定 可以默认绑定一个除全局对象和 undefined 意外的值，实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改 this 的能力： 1234567891011121314151617if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; // 这里的 this 是 Function.prototype 对象？ var fn = this; // 捕获 curried 参数，即除指定对象之外的参数 var curried = [].slice.call( arguments, 1 ); var bound = function() &#123; return fn.apply( // 如果 this 绑定到全局对象或者 undefined，那么就把 指定的 obj 对象绑定到 this，否则就不修改 this (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); // 注意这里返回的是 bound 执行后的返回值 return bound(); &#125;;&#125; 请问上面的 this 会指向谁呢？思考运行时函数调用的位置以及对象！ 总结四大绑定规则，ES6 箭头函数！空对象 DMZ ø 创建！ this –&gt; 函数调用位置判断 –&gt; 调用栈]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node 模块]]></title>
      <url>%2F2017%2F03%2F20%2FNode%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[2009 年提出的 node，使得 JavaScript 开始跳出浏览器，能够开始运行在服务器端。除了最简单的 web 程序，所有的程序都需要数据库，而 node 生态中的数据库更多。 所有主流关系型数据库（MySQL、MariaDB、PostgreSQL、Oracle、SQL Server）的接口都有，而 node 开发的出现带动了一种新式的数据库存储方式。“NoSQL 数据库”————《Node与Express开发》 Node 模块我们已经知道了闭包和模块的关系，让我们回顾一下模块模式的两个必要条件： 必须有外部的封闭函数，该函数至少被调用一次 封闭函数必须至少返回一个内部函数，这样内部函数才能在私有作用域中形成闭包，并访问或者修改私有状态。 需要注意的是 Node 模块和 npm 包管理是两个互相关联但又彼此不同的概念。 Node 模块：提供了一个模块化和封装的机制。 npm 包则提供了一种存储、版本化和引用项目（不限于模块）的标准范式。 1var express = require('express'); 这里的 require 是一个用来引入模块的 Node 函数。Node 默认会在目录 node_moudles 中寻找这些模块。而这里提到是 Node 自有模块的机制（不要在 node_moudles 中创建自己的模块）。 一般，我们会创建一个保存模块的目录。名字随意，但一半都称为 lib（library）。在此目录创建 fortune.js 12345678910111213// fortune.jsvar fortuneCookies = [ "Conquer your fears or they will conquer you.", "Rivers need springs.", "You will have a pleasant surprise.", "Whenever possible, keep it simple.",];exports.getFortune = function() &#123; var idx = Math.floor(Math.random() * fortuneCookies.length); return fortuneCookies[idx];&#125;; 在此注意全局变量输出的用法，如果需要对外暴露这个接口，需要手动挂载到 exports 上。在这个例子中，在模块外可以访问到函数 getFortune,但数组 fortuneCookies 是完全隐藏的。封装可以减少容易出错和比较脆弱的代码。 然后在你指定的 entry.js 入口文件中引入： 123// 引入 fortune.jsvar fortune = require('./lib/fortune.js'); 将 fortune.js 中的 exports 导出的方法放在 fortune 命名空间下。这里加载模块使用了相对路径，意思就是告诉 node 不要去 node_moudles 查找。然后你就可以用上面模块里的 getFortune 方法： 123app.get('/about', function(req, res) &#123; res.render('about', &#123; fortune: fortune.getFortune() &#125;);&#125;; 注释“NoSQL 数据库”：这个否定的叫法或许不恰当，“文档数据库”或“键/值对数据库”也许更加合适。它们提供了一种概念上更简单的数据存储方式。这种数据库有很多，MongoDB 就是其中的佼佼者。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[You don't know JavaScript(Chapter 1.4-1.5)]]></title>
      <url>%2F2017%2F03%2F17%2FYou-Don't-Know-Javascript3%2F</url>
      <content type="text"><![CDATA[这章会是一个全新的闭包认知世界！在这之前，先回顾一下前面所说的一些名词，解析执行–编译器编译–词法化–作用域–词法作用域–函数作用域–块作用域–遮蔽效应–let–const。作用域的概念想必已经清楚了，我们都知道任何声明在某个作用域内的变量，都将附属于这个作用域，但是作用域同其中变量的位置又有何关系呢？ 还有什么是作用域闭包，闭包对垃圾回收又是如何影响的？闭包能用来干什么呢？以及闭包实现模块的多种方式（一定要深究，你会发现他会让你了解到插件管理、依赖加载、模块化开发形式实现、模块化规范AMD/CMD等等一大片新的海域） 提升先有声明还是先有赋值？ 123a = 2;var a;console.log(a); // 2 12console.log(b); // ReferenceErrorvar b = 2; 回顾我们的编译阶段，在代码执行 var a = 2时，引擎会对其进行编译。其中一部分工作就是找到所有的声明，并用何时的作用域将他们关联起来。 因此，所以变量和函数的声明都会在代码执行前（编译）时被处理，也就是编译阶段会将所有变量和函数声明关联到对应作用域顶端，这个现象我们叫做提升。 先有声明后有赋值，提升的现象出现在每一个作用域中。 1234567function foo() &#123; var a; console.log(a); // undefined a = 2;&#125;foo(); 可以看到 foo(…) 函数自身会对内部 var 进行提升，需要注意的是函数声明也会提升，而函数表达式却不会。 12345678foo(); // 不是 REFERENCEERROR 而是 TYPEERROR!bar(); // ReferenceErrorvar foo = function bar() &#123; console.log(1); // console.log(bar);&#125;// 因为赋值操作执行时处理，声明编译时处理。 即使这里使用了具名的标识符 bar，但是在赋值之前还是无法在当前作用域中使用,然而赋值后将指向改为 foo 函数优先 注意一个细节：在多个“重复”声明的代码中，是函数会首先被提升，然后才是变量。 同时，重复的 var 声明会被忽略，重复的函数声明则会被覆盖。 作用域闭包启示、重生（闭包） 本质上，闭包无处不在，其实基于词法作用域书写代码是产生的自然结果。（有点绕，只是还没有识别、拥抱和影响闭包的思维环境） 如果你觉得—-如果你感觉一句话里有闭包而且读不懂。（请把闭包换成引用） 不要把闭包想象成多少高大上的东西，它不过是一个能够记住并访问所在作用域的函数，当然你也可以在当前词法作用域之外去执行函数。 把闭包想像成一种思维方式，它无处不在，只是你还没有意识到它而已。 这不是新的语法或模式才能使用的工具。 闭包是基于词法作用域书写代码是产生的自然结果，你需要的就是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。 或许，这是种让你重新简化认识这个世界（JavaScript）的方式。 实质问题 说完了态度和概念，来看看闭包是如何呈现的： 123456789101112// eg.1？？？？？这是闭包吗？function foo() &#123; var a = 2; funtion bar() &#123; console.log( a ); // 2 是外部作用域 foo(...) 的变量的值 &#125; bar();&#125;foo (); 这是闭包吗？函数 bar() 可以访问外部作用域中的变量 a（这里不就是个 RHS 引用查询么？）。确切来说应该不是吧！ 这不就是词法作用域的查找规则么？ 问题来了，闭包难道不适用这些规则？实际上这些规则只是闭包的非常重要的一部分。 eg.1 只是一个涵盖了 foo() 作用域的闭包（当然往上到全局也行）。也可以认为 bar() 被封闭在 foo() 作用域中。 12345678910111213141516// eg.2function foo() &#123; var a = 2; function bar() &#123; console.log( a ); //2 &#125; return bar;&#125;var baz = foo();baz(); // 2 ————baz 是 foo() 执行后的返回函数的引用// baz() 相当于执行了该返回函数，也就是 bar() 函数。 在这个例子中， bar() 引用了 foo() 的 a，同时被 return 到了全局，被 baz() 在外部调用。 同时在 foo() 执行之后，引擎的垃圾回收通常会来释放不再使用的内存空间。foo() 看上去不再被使用，所以很自然的会考虑对齐进行回收。 而‘闭包’的左右就在这里，由于外部变量 baz 保持着对 bar() 的引用，这就导致了 foo() 的作用域没有被销毁，因为 bar() 本身还在使用。 由于 bar() 声明的位置在 foo() 内部，使得 foo() 的作用域一直存在，bar() 在之后的任何时间都可以进行引用。 这个引用就叫做闭包。 因此，在几微秒之后变量 baz 被实际调用（调用函数内部 bar），它可以访问 bar() 和 foo() 的作用域; 在这里，foo() 将 bar() 以返回值的形势传递给外部，同样可以使用其他方式： 123456789101112131415161718// eg.3function foo() &#123; var a = 2; function baz()&#123; console.log( a ); // 2 &#125; bar( baz ); // 传递给 bar，此时 fn = baz；&#125;function bar( fn )&#123; fn(); // 这也是闭包！&#125;foo();bar(); // 2 把内部函数 baz 传递给 bar，当调用这个内部函数时(fn),它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为他能够访问 a。 这个就是函数传递！（直接的哦） 1234567891011121314151617181920// eg.4var fn;function foo()&#123; var a = 2; function baz()&#123; console.log( a ); &#125; fn = baz; // 将 baz 分配给全局变量&#125;function bar()&#123; fn(); // 这就是闭包！ ‘就是个引用’&#125;foo();bar(); // 2 只要是闭包，就持有对原始定义作用域的引用，不管是用什么手段将内部函数传递到所在的词法作用域之外的。 只要执行这个函数就会使用闭包。 现在懂闭包这个概念了把！不懂的继续往下看12345678910// eg.5function wait(message)&#123; setTimeout( function timer()&#123; console.log( message ); &#125;, 1000);&#125;wait( "hello closure!" ); 将一个内部函数传递（timer）给 setTimeout(…)。 timer 具有涵盖了 wait(…) 作用域的闭包，因此还保留着对变量 message 的引用。 这里的 wait() 在执行1s后， setTimeout 会保持这对第一个参数的引用，这里是 timer，引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 深入到引擎的内部原理中，内置的工具函数setTimeout(..) 持有对一个参数的引用，这个参数也许叫作fn 或者func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的timer 函数，而词法作用域在这个过程中保持完整。 来看 jQuery 的例子： 1234567891011eg.6function setupBot(name, selector) &#123; $( selector ).click( function activator() &#123; console.log( "Activating: " + name ); &#125; );&#125;setupBot( "Closure Bot 1", "#bot_1" );setupBot( "Closure Bot 2", "#bot_2" ); jQuery 添加事件的写法。（这居然也是闭包，呵呵） 现在你懂了？（懵逼）本质上无论何时何地，如果将函数（访问他们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包（引用）在这些函数中的应用。 定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中、只要使用了 回调函数，实际上就是在使用闭包！ 来回顾下 1.3 中遗留的 IIFE 问题,为什么说 IIFE 是典型的闭包！（以及作者对此倍感争议） 12345eg.8var a = 2;(function IIFE() &#123; console.log( a );&#125;)(); 示例中的函数是在当前作用域执行的，并非在外部或者其他作用域执行。（这就是作者为什么认为这不算闭包，因为它只是在词法作用域规则下使用了 RHS 引用查询。说白了 a 不是闭包发现的，而是查找的到的。） 但是，IIFE 本身的确创建了闭包，而且也是最常用来创建可以被封闭起来的闭包的工具。 循环闭包处理事情的本身最重要的是你需要明白你在做什么，而不受他人影响。 说明闭包，常见的还是 for 循环的例子： 123456789101112eg.9for (var i=1; i&lt;=5; i++) &#123; setTimeout( function()&#123; console.log( i ); &#125;, i*1000 );&#125;// 过 1s 6 // 过 1s 6// 过 1s 6 // 过 1s 6 // 过 1s 6 这里的每次迭代过程中，第一个参数只是个什么都没有的空作用域。引擎处理这里的循环呢，只是那么一丁丁丁丁丁点儿时间，所有的定时器会形成一个队列，等到循环结束（i = 6）=&gt; 第一个定时器事件触发 =&gt; 第二个定时器事件触发 =&gt; 第三个定时器事件触发 =&gt; 第四个定时器事件触发 =&gt; 第五个定时器事件触发 因为作用域是空的，i 只能往上找，那么结果当然是 6 啊。 那么该如何改进呢，就是在循环的时候做手脚，把 i 存进该方法的作用域内，那么执行的时候自然就会正确输出！ 123456789eg.10for (var i=1; i&lt;=5; i++)&#123; (function() &#123; var j = i; setTimeout(function timer()&#123; console.log( j ); &#125;,j*500); &#125;)();&#125; 你当然可以把 i 作为参数传进去，设置默认的参数，这样就不需要 var j = i； 12345678eg.10-2for (var i=1; i&lt;=5; i++)&#123; (function(j) &#123; setTimeout(function timer()&#123; console.log( j ); &#125;, j*500); &#125;)( i );&#125; 这里的 j 你也可以叫 i，叫什么并不能影响它是 setTimeout(…) 作用域内的变量。 你还记得块作用域么？ 我们在这里使用 IIFE 每次都会创建新的作用域，这是 for 循环带来的。 也就是说，每次迭代我们都需要一个块作用域。那么为什么不用 let 声明，来劫持块作用域，并且在这个块作用域内声明一个变量。 1234567eg.11for (var i=1; i&lt;=5; i++) &#123; let j = i; //闭包的块作用域 setTimeout( function()&#123; console.log( j ); &#125;, j*1000 );&#125; 需要注意的是，for 循环头部的 let 声明还有一个特俗的行为。这个行为指出变量在循环过程中不止被声明一次，而是每次迭代都会进行声明。而随后的迭代都会使用上一个迭代结束的值来初始化这个变量，就他会 let j = 上个j ,然后 let j = i,那么我们知道变量的重复声明是无效的，仅仅赋值会生效;那么不就可以改了么 需要注意的是，这个行为是在 for 循环内的哦，如果你写到其他里面可能就不算了哦 123456eg.11for (let i=1; i&lt;=5; i++) &#123; setTimeout( function()&#123; console.log( i ); &#125;, i*1000 );&#125; 可以看到，闭包和块作用域联手，能填好多坑！ 模块闭包的强大威力不仅于此，还有一个就是模块。虽然看起来和闭包毫无干系！ 这个就有点懵了： 123456789101112eg.12function foo() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125;; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125;&#125; 在函数里面定义了 doSomething() 和 doAnother() 函数，而且内部引用了 foo() 的变量，也就是说 foo() 内部变量和函数的词法作用域（这就是闭包）也就是 foo() 的内部作用域。 函数也是对象（废话︿(￣︶￣)︽(￣︶￣)︿） 如果这样写就清楚了： 123456789101112131415161718192021222324eg.13function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 这里 CoolMoudle() 函数返回的是 json 对象（内部函数的引用，而保持内部数据变量隐藏且私有的状态）， foo 是该对象的引用，借此将内部函数暴露给了 foo 模块。如果不执行外部函数，内部作用域和闭包都无法被创建。 可以将这个对象类型的返回值看作“ 模块的公共 API” 常见的实现模块模式的方法通常被称作模块暴露。这里展示的是其变体。 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery 就是一个很好的例子。jQuery 和$ 标识符就是jQuery 模块的公共API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。 模块模式的两个条件 必须要有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 上一个示例代码中的 CoolMoudle() 是独立的模块创建器，可以被调用任意多次，每次调用都会创建新的模块实例。对其改进来实现单例模式： 1234567891011121314151617var foo = (function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;)();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 模块函数被转换成 IIFE，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符 foo。 模块也是普通的函数，因此也可以接受参数； 123456789101112131415function CoolModule(id) &#123; function identify() &#123; console.log( id ); &#125; return &#123; identify: identify &#125;;&#125;var foo1 = CoolModule( "foo 1" );var foo2 = CoolModule( "foo 2" );foo1.identify(); // "foo 1"foo2.identify(); // "foo 2" 但是这里相当于生成了两个模块实例。 模块模式还有另一个简单而且强大的变化用法就是，为将要作为公共 API 返回的对象命名。 12345678910111213141516171819202122232425262728var foo = (function CoolModule(id) &#123; function change() &#123; // 修改公共API publicAPI.identify = identify2; &#125; function identify1() &#123; console.log( id ); &#125; function identify2() &#123; console.log( id.toUpperCase() ); &#125; var publicAPI = &#123; change: change, identify: identify1 &#125;; return publicAPI;&#125;)( "foo module" );foo.identify(); // foo modulefoo.change();foo.identify(); // FOO MODULE 模块实例的内部保留了对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。 现代的模块机制模块大多数依赖加载器或管理器。本质上是将这种模块定义的方法封装进一个友好的 API。来看一个例子视其核心： 123456789101112131415161718192021var MyMoudles = (function() &#123; var moudles = &#123;&#125;; function define(name, deps, impl) &#123; for (var i=0; i&lt;deps.length; i++) &#123; // 在这里取得模块的依赖 deps[i] = moudles[deps[i]]; &#125; // 这里是核心，保持对其他模块的引用 moudles[name] = impl.apply( impl, deps ); &#125; function get(name) &#123; return moudles[name]; &#125; return &#123; define: define, get: get &#125;&#125;)(); MyModules的define方法包含name，deps，impl三个参数; name表示是模块名称，deps表示是依赖项，impl表示实现。 关键是modules[name] = impl.apply( impl, deps ); 这一句，上面的for循环将一个模块名称数组先转成一个包含具体模块的数组，然后apply给具体的实现方法。相当于是注入了依赖项。 123456789101112131415161718192021222324252627282930313233// 定义2个模块，并测试引用包的依赖。MyModules.define( "bar", [], function() &#123; function hello(who) &#123; return "Let me introduce: " + who; &#125; return &#123; hello: hello &#125;;&#125; );MyModules.define( "foo", ["bar"], function(bar) &#123; var hungry = "hippo"; function awesome() &#123; console.log( bar.hello( hungry ).toUpperCase() ); &#125; return &#123; awesome: awesome &#125;;&#125; );var bar = MyModules.get( "bar" );var foo = MyModules.get( "foo" );console.log(bar.hello( "hippo" )); // Let me introduce: hippofoo.awesome(); // LET ME INTRODUCE: HIPPO 注意到定义foo模块的时候，依赖了bar模块，只需要在deps这个参数加入[“bar”]即可。 AMD 和 CMD 都是将模块的定义封装进一个友好的 API，就是 require.js 和 sea.js 中的 define 方法。上面的两个代码示例是一个现代模块实现 引申到其他，比如插件管理，依赖加载，API 统一管理等等（我也不知道对错，还是不太懂，需要深究） 但是上面的例子大致就是将依赖的其他此法作用域中的函数或者变量，封装进一个 API，保持对这些标识符的引用，这样我们就能够使用别人的方法或者工具。这其实就相当于闭包（这里使用了 apply 来保持对依赖的引用） 未来的模块机制其实说白了就是 ES6 的 moudle！ import &amp; export default import 可以将一个模块中的一个或多个API 导入到当前作用域中，并分别绑定在一个变量上。 module 会将整个模块的API 导入并绑定到一个变量上。 export 会将当前模块的一个标识符（变量、函数）导出为公共API。这些操作可以在模块定义中根据需要使用任意多次。 总结当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。 闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 模块有两个主要特征： 为创建内部作用域而调用了一个包装函数； （2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[You don't know JavaScript(Chapter 1.2-1.3)]]></title>
      <url>%2F2017%2F03%2F16%2FYou-Don't-Know-Javascript2%2F</url>
      <content type="text"><![CDATA[什么是词法化和词法作用域？ 你知道为什么不推荐 eval(…) 和 with 吗，以及这两者如何造成了性能下降的？ 什么是函数作用域？ 私有变量是怎么实现的？ 命名空间如何规避冲突？匿名函数的写法以及有点在哪儿？ ES6又是如何实现块作用域，babel 又是如何将其编译成兼容ES5的呢？ try/catch 仅仅用来调试吗？ 词法作用域回到编译器工作的第一个阶段，叫做词法化（单词化）。即对源代码中的字符进行检查，如果是有状态的解析过程，还会富裕单词意义。 词法作用域就是定义在词法阶段（查找标识符）的作用域。换句话说，就是在你写代码的时候你的变量和块作用域写在哪里，就决定了词法作用域的范围，这一切都是可以估量的（那么什么是不可预计的呢？），因此在词法分析阶段会保持作用域不变。（书写位置决定范围） 查找，作用域查找会在找到都一个匹配的标识符停止。在多层嵌套作用域中可以定义同名的标识符，这叫做遮蔽效应（内部遮蔽外部唯一吗？），查找由内而外。 备注：全局变量会自动成为全局对象（window、global）的属性，因此可以通过全局对象属性的引用来进行访问（对于被遮蔽的变量能够通过这种方式查到，但是仅限于全局变量，非全局则是被替换）。 欺骗词法 eval &amp; with eval: 我们经常动态插入代码，而引擎则会认为被 eval 插入的代码所处位置就是 eval 所处的作用域，这就导致了该词法作用域会在运行期间被修改（例如声明局部变量导致内容被替换等等）。 with：通常被当做重复引用一个对象中多个属性的快捷方式，问题就出在这里，万一里面包含了词法作用域内没有的属性或变量，那么就会造成全局污染（非严格模式下赋值查询的弊端）。需要注意的是，with 可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，同时将该对象的属性定义为词法作用域的词法标识符。 这两种方式都会造成词法解析过程的不确定性，因为无法对作用域查找进行优化，引擎会认为我做的这些都是白做的，最终的结果就是性能的严重下降，甚至是带来安全的隐患。 好消息是：严格模式下两则都被禁用了。 函数作用域和块作用域请把一个函数作用域想象成一个气泡（虽然不合理） 函数中的作用域 属于这个函数的全部变量都可以在整个函数的范围内使用以及复用（实际在嵌套的作用域中也可以访问）。这样的设计方案，充分利用了 JavaScript 变量可根据需要改变值类型的‘动态’特性。与此同时，意味着全局变量随时都能被任意位置访问，这就会带来意想不到的结果。 隐藏内部实现 123456789101112function doSomething(a) &#123; b = a + doSomethingElse( a * 2 ); console.log( b * 3）；&#125;function doSomethingElse(a) &#123; return a - 1;&#125;var b;doSomething( 2 ); // 15 这是一段原文中的例子，b 和 doSomethingElse 本该是 doSomething 的内部实现，然后因为写在函数外部，使得外部作用域拥有‘访问权限’，一旦被修改，那么我们就无法从 doSomething 得到我们预期想要的结果。这就是为何需要隐藏！ 先声明函数，然后在里面写代码是传统的思维。反过来思考，将一段代码挑选出来，用函数声明对其进行包装，实际上就相当于将代码隐藏了。于是就在这个代码片段周围新建了一个作用域气泡。（用作用域去隐藏一段代码，为什么要隐藏？） 软件设计的最小授权或最小暴露原则，指的是最小限度地暴露必要内容，而将其他内容都‘隐藏’起来，比如某个模块或对象的 API 设计。阻止部分访问，实现变量或函数的私有。 规避冲突 12345678910111213function foo() &#123; function bar(a) &#123; i = 3; //修改了 for 循环所属作用域中的 i console.log( a + i ); // a 为8，所以输出 11，但是 i 还是为3 &lt; 10 &#125; for (var i=0; i&lt;10; i++) &#123; console.log(i); // 3 + 1 = 4 bar( i * 2); //糟糕，无限循环了！因为声明会提前，赋值是运行到哪儿才会执行哪儿 &#125;&#125;foo() // 日志打印(4 11)无限循环; 看上面的例子，因为 bar 函数内部忘记声明变量 i（隐藏），导致全局创建了 i 变量，以致于污染了 for 循环（循环内var 会提到 foo的顶部，在执行 bar 时 i 被赋值，所以 i 始终为 3）。 前面我们提过‘遮蔽效应’，‘隐藏’作用域中的变量和函数带来的好处就是可以避免同名标识符之间的冲突。 全局命名空间：第三方库在实现过程中如果没有妥善地将内部私有函数和变量隐藏起来，那么就极易引发冲突（jQuery 的实现，$/jquery 的使用）。 模块管理：现代的模块机制，使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式导入到另外一个特定的作用域中（webpack 就是一个模块化打包工具，require/AMD/ES6 moudle 是规范）。 函数作用域 上面我们提到如何隐藏内部实现，通过包装函数来讲变量或者函数隐藏起来，但是这仍旧会生成一些具名函数（比如 foo()），这就意味着 foo 这个名字本身‘污染’了当前作用域。12345678(function foo() &#123; // &lt;-- 注意开头 （function... var a = 3; console.log(a); // 3&#125;)(); // &lt;-- 注意结尾 ...)()console.log( a ); //Uncaught ReferenceError: a is not defined 可以看到外部无法访问到 a 变量。 该包装函数声明以（function… 而不是以 function… 开始，函数会被当做函数表达式而不是一个标准的函数声明来处理。 !important &gt;&gt;&gt; 区分函数声明和表达式最简单的方法是看 function 关键字出现的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。(function foo() { .. }) 作为函数表达式意味着，foo 只能在 .. 所代表的位置中被访问，外部作用域作为无法访问，也就不会非必要的污染外部作用域。 匿名和具名 来看一个熟悉的场景：123setTimeout( function() &#123; console.log('blablabla')&#125;, 1000); 这个叫做匿名函数表达式，因为 function() {} 没有函数名，也就是名称标识符。函数表达式可以匿名，但是函数声明则不可以省略函数名————非法操作。 匿名函数表达式的缺点： 匿名函数在栈追踪不会显示出有意义的函数名，使得调试很困难。 没有函数名，当需要进行引用的时候只能用 过期的 arguments.callee 引用，例如递归，例如事件触发之后解除监听。 匿名函数省略了函数名，代码可读性变差。 解决办法：行内函数表达式————匿名和具名都对此无影响，解决了上述问题；1234// 最佳实践setTimeout( function timeoutHandler() &#123; console.log('blablabla')&#125;, 1000); 立即执行函数表达式 函数写在括号内变成了一个函数表达式，那么在后面加一对括号，就可以立即执行这个函数。 IIFE：（Immediately Invoked Function Expression）立即执行函数表达式 12345var a = 3;(function IIFE(a) &#123; console.log(a); &#125;)(2);console.log(a); // 3 另外一种写法，功能上一致，任凭喜好：12345var a = 3;(function IIFE(a) &#123; console.log(a); &#125;(2));console.log(a); // 3 IIFE 用法进阶： 1234567891011var a = 2;(function (global) &#123; var a = 3; console.log(a); //3 console.log(global.a); // 2 &#125;)(window);console.log(a); // 2 可以帮助你改进代码风格，使得对全局对象的引用变得比引用一个没有‘全局’资源的变量更加清晰（global.a 很明显是全局变量）。 还有一种常见的模式，就是参数默认为 undefined 1234567891011undefined = true; // 这里有坑(function IIFE( undefined ) &#123; var a; if (a === undefined) &#123; console.log("Undefined is safe here") &#125; &#125;)(); 目的是为了解决 undefined 标识符的默认值被错误覆盖导致的异常，这样的话即使在对于位置不传入任何值，内部的 undefined 还是 undefined。 IIFE 倒置代码运行顺序的用法（广泛用于 UMD 项目，其实看完会发现函数表达式内部会有一次调用参数（这里是传入进去的函数）的过程，参数（函数）会在这里执行）： 1234567891011121314151617181920212223var a = 2;console.log('one step');(function IIFE( def ) &#123; console.log('two step'); def( window ); console.log('three step');&#125;)(function def( global ) &#123; console.log('four step'); var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 console.log('five step');&#125;);// one step// two step// four step// 3// 2// five step// three step 这里让我想到了一个问题，操作符的优先级。MDN 上有介绍。 函数表达式 def 定义在片段的第二部分，然后当做参数（这个参数也叫做 def ）被传进 IIFE 函数定义的第一部分中。最后，参数 def （也就是传进去的函数）被调用，并将 window 传入当做 global 参数的值。 块作用域 函数作用域是 JS 中最普遍的作用域单元，但是其他类型也是存在的，而且实现维护起来可以更加优秀和简洁。 主要使用 JavaScript 开发的会对块作用域很陌生（非常赞同，以前甚至没有听过） 看个例子吧： 1234for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125;//你居然和我说这个就是块作用域？ 通常我们在 for 循环头部定义变量 i，事实上，我们只想在 for 循环内部的上下文使用它（没错=。=），而忽略了 i 会被绑定在外部作用域（函数或者全局）的事实（意思就是 for 循环不会像函数那样生成作用域气泡）。 再看一个例子： 1234567var foo = true;if (foo)&#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125; 同样是 if 条件，同样不会生成作用域气泡，那么你在里面使用 var，bar 最终还是属于外部作用域。这段代码只是为了可读性而可以伪装出的形式上的块作用域，如果用了，要确保没在其他地方使用 bar 只能靠自觉，这是不可取的。 with with 其实就是一个块左右的例子，因为他会单独生成一个作用域气泡，而且用 with 对象创建出的作用域仅在 with 声明中而非外部作用域中有效。 try/catch 很少人知道 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分局会创建一个块作用域。（我认为本书作者牛的地方就在这里，真的带你去了解任督二脉） 12345678910try &#123; undefined(); //执行一个非法操作来强制制造一个错误 err 用 undefined();&#125;catch( err ) &#123; console.log( err ); // TypeError: undefined is not a function&#125;console.log( err ); // ReferenceError: err is not defined 我们可以看到 err 仅在 catch 内部可以被访问，而在外部无法获得 undefined(); 来强制生成错误catch( err ){…}; 来捕获错误信息这个行为已经被标准化，除了IE其他浏览器大部分都已实现。但是当用一个作用域中的两个或者多个 catch 分句用同样的标识符名称声明错误变时，很多静态检查工具会发出警告。实际上我们知道因为 catch 实际上是块作用域，所以并不是重复定义变量，因为所以得变量都被安全的限制在 catch 块作用域内部。所以有人会命名 err1，err2 等等，有人则直接关闭静态检查工具对重复变量名的检查。这个其实很有用，因为能够帮助人们将 ES6 的一些新特性编译成能够兼容 ES5 的代码。 let 作业就是将变量绑定在 {…} 内部，同意 if 和 for 这些不会生成作用域气泡的条件语句也能够拥有自己私有的变量了。（想想还真是记得(≧▽≦)/！） 同样道理，直接将 let 写在 {…} 内部会隐式的将变量附加在一个块作用域上，如果没有密切关注，仍旧习惯性的移动就会导致代码混乱。解决办法就是认为添加一个显式的块： 123456789if foo &#123; &#123; // &lt;-- 显式的块 let bar = foo * 2; bar = something( bar ); console.log( bar ); &#125;&#125;console.log( bar ); // ReferenceError 垃圾回收 块作用域非常有用，这牵扯到闭包的垃圾回收机制相关。 这里留一个疑问？为什么闭包会导致垃圾无法及时回收呢？使用块作用域，能清楚的告知 JS 引擎，那些变量是使用一次后不再被使用的。 let 循环 12345for (let i=0; i&lt;10; i++) &#123; console.log( i ); // 1 2 3 4 5 6 7 8 9&#125;console.log( i ); // ReferenceError let 在 for 循环中的使用，实际上是将 i 绑定到了 for 循环的块中，而且是绑定到具体每一次循环迭代，确保使用上一个循环迭代结束时的值重新进行赋值。 12345678&#123; let j; for (let j=0; j&lt;10; j++) &#123; let i = j; console.log( i ); // 0 1 2 3 4 5 6 7 8 9 &#125;&#125;;console.log( j ); // RefeerenceError const const 同样用来可以创建作用域变量，但是其值为固定的（常量–&gt;如果是对象，那么固定的是其引用地址）。之后任何修改都会引起错误 总结：函数是 JavaScript 中最常用的作用域单元，默认声明在一个函数内部的变量会被隐藏，这是刻意为之的软件设计原则。但是函数并不是唯一的作用域单元。块作用域是指的变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{…}内部,想想命名空间啊骚年）。从 ES3 开始，try/catch 结构在 catch 分局中具有块作用域。ES6 引入了 let 关键字（var 的亲戚），用来在任意代码块中声明变量。块作用域的出现不仅仅是函数作用域的替代方案，能为我所用就好。（工具也是，不要纠结sublime还是atom还是vscode，虽然我最青睐两边！🙃）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[You Don't Know JavaScript(Chapter 1.1)]]></title>
      <url>%2F2017%2F03%2F14%2FYou-Don't-Know-JavaScript%2F</url>
      <content type="text"><![CDATA[JS 被广泛使用，它是支撑起网页内容交互体验的技术基础。JavaScript 极易上手，但是真正掌握的人却比较少。日常所用的仅仅是它的冰山一角。《你不知道的 JavaScript》（后文略写《本书》）所做的事情就是深入理解 JavaScript，尤其是难的那一部分。每次遇到 JavaScript 中出乎意料的部分时，能做到不去责怪语言，而是从中探究排除多样性，去理解 JavaScript 中“好的地方”，学会欣赏一门语言。 作用域 编译原理 “动态”，“解释执行”每个人都知道，但《本书》认为其实为一门编译语言（它不是提前编译的，编译结果也不能在分布式系统中进行移植）。 一般的编译器，其一段源代码执行前经历以下三步： 分词/词法分析（Tokenizing/Lexing） 解析/语法分析（Parsing Abstract Syntax Tree，“抽象语法树”） 代码生成（将 AST 转换为可执行的代码） 然而 JavaScript 引擎要复杂的多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，对冗余元素进行优化。大部分情况下编译发生在执行前的几微秒。在作用域背后，JavaScript 引擎使用了各种方法（JIT，延迟编译甚至重编译）来保证性能最佳。 理解作用域 处理程序的角色们： 引擎：负责JS程序编译以及执行 编译器：负责语法分析以及代码生成 作用域：收集并维护由所有声明的标识符组成的一系列查询，并实施一套严格的规则以确立访问权限 对话模拟： 变量的赋值操作过程 编译器变量(对象)查询的方式 LHS 查询（赋值目标的查询，找到他，并且把这个东西给他。） RHS 查询（取得目标源的值，得到某某的值。） 引擎与作用域的职责 作用域嵌套 作用域嵌套形成了作用域链，一旦在当前作用域无法查找到目标，就会向外传递（事件冒泡），直到最外层全局环境。 异常 为何区分 LHS 和 RHS 至关重要，因为在变量未声明的情况下，这两中查询行为是不一样的。 如果 RHS 查询是在所有作用域中遍寻不到所需要的变量，引擎就会抛出 ReferenceError 异常。 如果 LHS 查询子啊所有作用域中遍寻不到所需变量，就会在全局作用域中创建一个具有该名称的变量，并返回给引擎（非严格模式） 严格模式下，LHS 查询没找到变量同 RHS 一样抛出 ReferenceError 异常 严格模式下，RHS 查询找到目标变量，但对该变量的值进行不合理的操作，例如对非函数类型的值进行函数调用，引用 undefined 或者 null 类型的值中的属性，会抛出 TypeError（类型错误） ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功，找到了变量但是对结果的操作是非法或不合理的。 总结：作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。如果相对查找的变量进行赋值，那么就会用 LBS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 ‘=’ 操作符或调用函数是传入参数的操作都会导致关联作用域的赋值操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVC Backbone]]></title>
      <url>%2F2017%2F03%2F11%2FMVC-Backbone%2F</url>
      <content type="text"><![CDATA[最近阅读了《基于MVC的JavaScript web富应用开发》（后文简称《MVC》），文章第十二章介绍了 Backbone.js，再次激发了我对此框架的兴趣。在看这本书之前了解过 vue，也被其所吸引，而正如作者分享的经验， MVC 是 MV* 发展的前身。也因此让自己想要更加深入地去了解，MVC 到底是什么？借此从 Backbone 入手来学习这类库（框架）的设计思想。 Backbone 的特点 Backbone 是构建 JavaScript 应用程序的一个优秀类库，他的优美之处在于其简洁。这是一个轻量类库，覆盖了基础的功能，同时提供了最大的灵活性。（大小请参阅官方文件）MVC 是贯穿 Backbone 核心的模式。提供了模型、控制器和视图——骨架。Backbone 唯一以来 underscore.js，其提供非常有用的工具和 js 函数。除了 underscore，还可以使用 jQuery zepto 来提升 Backbone 处理视图的能力 引用来自《MVC》-chapter 12 知乎上关于 Backbone 的回答Backbone 最适合的应用场景是单页面应用，并且页面上有大量数据模型，模型之间需要进行复杂的信息沟通。Backbone 在这种场景下，能很好的实现模块间松耦合和事件驱动。 其他适用产品还有微博，网易微博的前端设计也是和 Backbone 类似的一个结构。 Backbone 的优点和一些经验 Tip： View 的划分将页面上的视图元素解耦，粒度细化。View 间通过事件和 Model 通讯，避免了 DOM 事件的滥用。Model 和 Restful 的通讯方式对于后端人员非常友好。 MVC 架构清晰， 我有个常年写 Java 没写过 JS 的同事看 Backbone 很快就了解了整体设计，虽然这时候他还是不会写 JS。 Collection/Model 抽象了以前杂乱的 AJAX 请求，CRUD 请求变得非常非常方便。 强烈建议 View -&gt; Model 单向依赖，世界会美好很多。 配上一个模块化加载器例如 SeaJS 会很爽。 Backbone 的一些缺点，或者说一些尚未实现的 Feature： Model 层比较简单，如果要支持 One-To-One 或者 One-To-Many 等复杂数据关系时有些力不从心。还有 一个 Model 只能属于一个 Collection 这个设计，页面复杂的时候会很受局限。例如这个问题： http://www.zhihu.com/question/19843899 （补充：Backbone.Relations 插件是这个问题的一个解决方案 https://github.com/PaulUithol/Backbone-relational By zjhiphop） 同上，Model 只有基本的 CRUD 操作，不能很好的扩展，Backbone.sync 方法写的不太灵活，要想扩展就得重写 sync 方法。 View 层没有很强的 Page 管理机制，比如通过 URL 切换改变整个页面时，页面上尚存的 View 如何处理？直接销毁的话，是否要销毁关联的 Model、Collection？Cache 住？如何管理 Cache？ 内存管理需要比较小心，缺乏机制避免创建重复 Model。 extends override 父类方法的时候得写一串的代码，就不能实现个 _super 方法么……（SuperClass.prototype.someMethod.apply） 对调试非常不友好。 作者有代码洁癖（也是加分项），this.$el 大家呼唤了这么久才加上，估计今生也看不到 this._super。更新慢。 总体来说 Backbone 还很轻，框架很漂亮但是有些细节还比较粗糙。用之前要做好对 Backbone 进行大量扩展甚至 Hack 的准备。 作者：pw来源：知乎 链接 模型1Backbone.Model 模型是保存应用程序数据的地方。可以想象为 APP 原始数据精心设计的抽象，并且添加了一些工具函数和事件。 模型和属性使用 set() 和 get() 来设置和获取实例中的属性。12var user = new User();user.set(&#123;name: "yevvb"&#125;);//hash 形式的表示对象 集合集合就是对模型实例的数据进行管理。文章中举了重建 twitter 关注和粉丝的例子，FOLLOWERS 和 FOLLOWEES，两者都是由 User 实例来填充数据，虽然来自于同一个 Model，但是包含了不同的 Model 实例（User 实例）。 控制集合内部顺序123456var Users = Backbone.Collection.extend(&#123; // 通过 comparator（） 函数来实现 comparator: function(user)&#123; return user.get("name"); &#125;&#125;); 视图Backbone 视图并不是模板本身，而是一些控制类。代表了一个 UI 逻辑块，负责一个简单的 DOM 的内容。比如说：控制元素的显隐，按钮的不同状态等等… 12345var UserView = Backbone.View.extend(&#123; el: $(&quot;.users&quot;)&#125;);new UserView(&#123;id: &quot;followers&quot;&#125;); 渲染视图每个视图都有一个 render() 函数，默认情况不做任何操作。一旦视图修改就需要 repaints，就应该调用此函数。模板可以依赖于其他工具 underscore 等等都可以。 即使是未插入到页面中去的 model 实例，其仍旧拥有自己的 el 元素，视图可在任何时候渲染，然后一次性插入到 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。 12345678var TodoView = Backbone.View.extend(&#123; template: _.template($(&quot;#todo-template&quot;).html()), render: function() &#123; $(this.el).html(this.template(this.model.toJSON())); // 返回以便于链式调用，非常重要 return this; &#125;&#125;); 委托事件事件必不可少，他是用户行为–交互的基础。 Backbone 视图提供了一种添加事件到 el 的快捷方法。12345678var TodoView = Backbone.View.extend(&#123; events: &#123; &quot;change input[type=checkbox]&quot; : &quot;toggleDone&quot;, &quot;click .destroy&quot; : &quot;clear&quot;, &#125;, toggleDone: function(e)&#123; /* ... */&#125;, clear: function(e)&#123; /* ... */&#125;&#125;); 绑定和上下文一旦视图发生改变，就会触发 change 事件，使得应用程序的视图和与之对应的模型数据是同步绑定的。而此时唯一需要注意的是 this 指示的上下文会发生变化。 控制器Backbone 的控制器将应用程序的状态和 URL 的 hash 片段关联在一起，使 URL 地址可分享，也可作为书签使用。本质上，控制器由一些路由和函数构成，当导航到这些路由时那些函数就会被调用。 123456789101112131415var PageController = Backbone.Controller.extend(&#123; routes: &#123; &quot;&quot;: &quot;index&quot;, &quot;help&quot;: &quot;help&quot;, // #help &quot;search/:query&quot;: &quot;search&quot;, // #search/kiwis &quot;search/:query/p:page&quot;: &quot;search&quot; // #search/kiwis/p7 &#125;, index: function()&#123; /* ... */ &#125;, help: function() &#123; // ... &#125;, search: function(query, page) &#123; // ... &#125;&#125;); 与服务器同步的问题第一次如何从服务器获取模型数据（fetch）服务器端如何存储如何自定义行为todo 应用实践 总结：backbone 为我们解耦了模型、视图和控制层，结构清晰简洁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
