<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[You Don't Know JavaScript(Chapter 1.1)]]></title>
      <url>%2F2017%2F03%2F12%2FYou-Don't-Know-JavaScript%2F</url>
      <content type="text"><![CDATA[JS 被广泛使用，它是支撑起网页内容交互体验的技术基础。JavaScript 极易上手，但是真正掌握的人却比较少。日常所用的仅仅是它的冰山一角。《你不知道的 JavaScript》（后文略写《本书》）所做的事情就是深入理解 JavaScript，尤其是难的那一部分。每次遇到 JavaScript 中出乎意料的部分时，能做到不去责怪语言，而是从中探究排除多样性，去理解 JavaScript 中“好的地方”，学会欣赏一门语言。 作用域 编译原理 “动态”，“解释执行”每个人都知道，但《本书》认为其实为一门编译语言（它不是提前编译的，编译结果也不能在分布式系统中进行移植）。 一般的编译器，其一段源代码执行前经历以下三步： 分词/词法分析（Tokenizing/Lexing） 解析/语法分析（Parsing Abstract Syntax Tree，“抽象语法树”） 代码生成（将 AST 转换为可执行的代码） 然而 JavaScript 引擎要复杂的多，例如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，对冗余元素进行优化。大部分情况下编译发生在执行前的几微秒。在作用域背后，JavaScript 引擎使用了各种方法（JIT，延迟编译甚至重编译）来保证性能最佳。 理解作用域 处理程序的角色们： 引擎：负责JS程序编译以及执行 编译器：负责语法分析以及代码生成 作用域：收集并维护由所有声明的标识符组成的一系列查询，并实施一套严格的规则以确立访问权限 对话模拟： 变量的赋值操作过程 编译器变量(对象)查询的方式 LHS 查询（赋值目标的查询，找到他，并且把这个东西给他。） RHS 查询（取得目标源的值，得到某某的值。） 引擎与作用域的职责 作用域嵌套 作用域嵌套形成了作用域链，一旦在当前作用域无法查找到目标，就会向外传递（事件冒泡），直到最外层全局环境。 异常 为何区分 LHS 和 RHS 至关重要，因为在变量未声明的情况下，这两中查询行为是不一样的。 如果 RHS 查询是在所有作用域中遍寻不到所需要的变量，引擎就会抛出 ReferenceError 异常。 如果 LHS 查询子啊所有作用域中遍寻不到所需变量，就会在全局作用域中创建一个具有该名称的变量，并返回给引擎（非严格模式） 严格模式下，LHS 查询没找到变量同 RHS 一样抛出 ReferenceError 异常 严格模式下，RHS 查询找到目标变量，但对该变量的值进行不合理的操作，例如对非函数类型的值进行函数调用，引用 undefined 或者 null 类型的值中的属性，会抛出 TypeError（类型错误） ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功，找到了变量但是对结果的操作是非法或不合理的。 总结：作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。如果相对查找的变量进行赋值，那么就会用 LBS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。 ‘=’ 操作符或调用函数是传入参数的操作都会导致关联作用域的赋值操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVC Backbone]]></title>
      <url>%2F2017%2F03%2F11%2FMVC-Backbone%2F</url>
      <content type="text"><![CDATA[最近阅读了《基于MVC的JavaScript web富应用开发》（后文简称《MVC》），文章第十二章介绍了 Backbone.js，再次激发了我对此框架的兴趣。在看这本书之前了解过 vue，也被其所吸引，而正如作者分享的经验， MVC 是 MV* 发展的前身。也因此让自己想要更加深入地去了解，MVC 到底是什么？借此从 Backbone 入手来学习这类库（框架）的设计思想。 Backbone 的特点 Backbone 是构建 JavaScript 应用程序的一个优秀类库，他的优美之处在于其简洁。这是一个轻量类库，覆盖了基础的功能，同时提供了最大的灵活性。（大小请参阅官方文件）MVC 是贯穿 Backbone 核心的模式。提供了模型、控制器和视图——骨架。Backbone 唯一以来 underscore.js，其提供非常有用的工具和 js 函数。除了 underscore，还可以使用 jQuery zepto 来提升 Backbone 处理视图的能力 引用来自《MVC》-chapter 12 知乎上关于 Backbone 的回答Backbone 最适合的应用场景是单页面应用，并且页面上有大量数据模型，模型之间需要进行复杂的信息沟通。Backbone 在这种场景下，能很好的实现模块间松耦合和事件驱动。 其他适用产品还有微博，网易微博的前端设计也是和 Backbone 类似的一个结构。 Backbone 的优点和一些经验 Tip： View 的划分将页面上的视图元素解耦，粒度细化。View 间通过事件和 Model 通讯，避免了 DOM 事件的滥用。Model 和 Restful 的通讯方式对于后端人员非常友好。 MVC 架构清晰， 我有个常年写 Java 没写过 JS 的同事看 Backbone 很快就了解了整体设计，虽然这时候他还是不会写 JS。 Collection/Model 抽象了以前杂乱的 AJAX 请求，CRUD 请求变得非常非常方便。 强烈建议 View -&gt; Model 单向依赖，世界会美好很多。 配上一个模块化加载器例如 SeaJS 会很爽。 Backbone 的一些缺点，或者说一些尚未实现的 Feature： Model 层比较简单，如果要支持 One-To-One 或者 One-To-Many 等复杂数据关系时有些力不从心。还有 一个 Model 只能属于一个 Collection 这个设计，页面复杂的时候会很受局限。例如这个问题： http://www.zhihu.com/question/19843899 （补充：Backbone.Relations 插件是这个问题的一个解决方案 https://github.com/PaulUithol/Backbone-relational By zjhiphop） 同上，Model 只有基本的 CRUD 操作，不能很好的扩展，Backbone.sync 方法写的不太灵活，要想扩展就得重写 sync 方法。 View 层没有很强的 Page 管理机制，比如通过 URL 切换改变整个页面时，页面上尚存的 View 如何处理？直接销毁的话，是否要销毁关联的 Model、Collection？Cache 住？如何管理 Cache？ 内存管理需要比较小心，缺乏机制避免创建重复 Model。 extends override 父类方法的时候得写一串的代码，就不能实现个 _super 方法么……（SuperClass.prototype.someMethod.apply） 对调试非常不友好。 作者有代码洁癖（也是加分项），this.$el 大家呼唤了这么久才加上，估计今生也看不到 this._super。更新慢。 总体来说 Backbone 还很轻，框架很漂亮但是有些细节还比较粗糙。用之前要做好对 Backbone 进行大量扩展甚至 Hack 的准备。 作者：pw来源：知乎 链接 模型1Backbone.Model 模型是保存应用程序数据的地方。可以想象为 APP 原始数据精心设计的抽象，并且添加了一些工具函数和事件。 模型和属性使用 set() 和 get() 来设置和获取实例中的属性。12var user = new User();user.set(&#123;name: "yevvb"&#125;);//hash 形式的表示对象 集合集合就是对模型实例的数据进行管理。文章中举了重建 twitter 关注和粉丝的例子，FOLLOWERS 和 FOLLOWEES，两者都是由 User 实例来填充数据，虽然来自于同一个 Model，但是包含了不同的 Model 实例（User 实例）。 控制集合内部顺序123456var Users = Backbone.Collection.extend(&#123; // 通过 comparator（） 函数来实现 comparator: function(user)&#123; return user.get("name"); &#125;&#125;); 视图Backbone 视图并不是模板本身，而是一些控制类。代表了一个 UI 逻辑块，负责一个简单的 DOM 的内容。比如说：控制元素的显隐，按钮的不同状态等等… 12345var UserView = Backbone.View.extend(&#123; el: $(&quot;.users&quot;)&#125;);new UserView(&#123;id: &quot;followers&quot;&#125;); 渲染视图每个视图都有一个 render() 函数，默认情况不做任何操作。一旦视图修改就需要 repaints，就应该调用此函数。模板可以依赖于其他工具 underscore 等等都可以。 即使是未插入到页面中去的 model 实例，其仍旧拥有自己的 el 元素，视图可在任何时候渲染，然后一次性插入到 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。 12345678var TodoView = Backbone.View.extend(&#123; template: _.template($(&quot;#todo-template&quot;).html()), render: function() &#123; $(this.el).html(this.template(this.model.toJSON())); // 返回以便于链式调用，非常重要 return this; &#125;&#125;); 委托事件事件必不可少，他是用户行为–交互的基础。 Backbone 视图提供了一种添加事件到 el 的快捷方法。12345678var TodoView = Backbone.View.extend(&#123; events: &#123; &quot;change input[type=checkbox]&quot; : &quot;toggleDone&quot;, &quot;click .destroy&quot; : &quot;clear&quot;, &#125;, toggleDone: function(e)&#123; /* ... */&#125;, clear: function(e)&#123; /* ... */&#125;&#125;); 绑定和上下文一旦视图发生改变，就会触发 change 事件，使得应用程序的视图和与之对应的模型数据是同步绑定的。而此时唯一需要注意的是 this 指示的上下文会发生变化。 控制器Backbone 的控制器将应用程序的状态和 URL 的 hash 片段关联在一起，使 URL 地址可分享，也可作为书签使用。本质上，控制器由一些路由和函数构成，当导航到这些路由时那些函数就会被调用。 123456789101112131415var PageController = Backbone.Controller.extend(&#123; routes: &#123; &quot;&quot;: &quot;index&quot;, &quot;help&quot;: &quot;help&quot;, // #help &quot;search/:query&quot;: &quot;search&quot;, // #search/kiwis &quot;search/:query/p:page&quot;: &quot;search&quot; // #search/kiwis/p7 &#125;, index: function()&#123; /* ... */ &#125;, help: function() &#123; // ... &#125;, search: function(query, page) &#123; // ... &#125;&#125;); 与服务器同步的问题第一次如何从服务器获取模型数据（fetch）服务器端如何存储如何自定义行为todo 应用实践 总结：backbone 为我们解耦了模型、视图和控制层，结构清晰简洁。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
